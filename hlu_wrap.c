/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.20
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#include "Python.h"

/*************************************************************** -*- c -*-
 * python/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Python_TypeRegister
#define SWIG_TypeCheck       SWIG_Python_TypeCheck
#define SWIG_TypeCast        SWIG_Python_TypeCast
#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
#define SWIG_TypeName        SWIG_Python_TypeName
#define SWIG_TypeQuery       SWIG_Python_TypeQuery
#define SWIG_TypeClientData  SWIG_Python_TypeClientData
#define SWIG_PackData        SWIG_Python_PackData 
#define SWIG_UnpackData      SWIG_Python_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

#endif

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Python_MustGetPtr(p, type, argnum, flags)

/* Python-specific SWIG API */
#define SWIG_newvarlink() \
  SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr) \
  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type) \
  SWIG_Python_NewPackedObj(ptr, sz, type)
#define SWIG_InstallConstants(d, constants) \
  SWIG_Python_InstallConstants(d, constants)

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",              /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject *zero = PyInt_FromLong(0);
    PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
    Py_DECREF(zero);
  }
  return 0;

type_error:
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME(void *)
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject *n = PyInt_FromLong(1);
        PyObject_SetAttrString(inst,(char*)"thisown",n);
        Py_DECREF(n);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_NhlClass swig_types[0] 
#define  SWIGTYPE_p_float swig_types[1] 
#define  SWIGTYPE_p_ResInfo swig_types[2] 
#define  SWIGTYPE_p_nglPlotId swig_types[3] 
#define  SWIGTYPE_p_p_float swig_types[4] 
#define  SWIGTYPE_p_double swig_types[5] 
#define  SWIGTYPE_p_p_double swig_types[6] 
#define  SWIGTYPE_p_NhlString swig_types[7] 
#define  SWIGTYPE_p_NhlBoundingBox swig_types[8] 
#define  SWIGTYPE_p_void swig_types[9] 
#define  SWIGTYPE_p_int swig_types[10] 
#define  SWIGTYPE_p_nglRes swig_types[11] 
static swig_type_info *swig_types[13];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _hlu.so
  ------------------------------------------------*/
#define SWIG_init    init_hlu

#define SWIG_name    "_hlu"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <stdarg.h>
#include <ncarg/hlu/hluP.h>
#include <ncarg/hlu/ResListP.h>
#include <ncarg/hlu/AppI.h>
#include <ncarg/hlu/CoordArraysP.h>
#include <ncarg/hlu/TickMark.h>
#include <ncarg/hlu/Title.h>
#include <ncarg/hlu/Workstation.h>
#include <ncarg/hlu/WorkstationP.h>
#include <ncarg/hlu/XWorkstationP.h>
#include <ncarg/hlu/PSWorkstationP.h>
#include <ncarg/hlu/PDFWorkstationP.h>
#include <ncarg/hlu/LabelBar.h>
#include <ncarg/hlu/Legend.h>
#include <ncarg/hlu/TextItem.h>

/***********************************************************************
 *
 *  Include gsun header
 *
 ***********************************************************************/
#include "gsun.h"

/***********************************************************************
 *
 *  End GSUN functions
 *
 ***********************************************************************/

#include <ncarg/gks.h>

#include <Numeric/arrayobject.h>

#define min(x,y) ((x) < (y) ? (x) : (y) )
#define pow2(x)  ((x)*(x))

extern float *c_natgrids(int, float [], float [], float [],
                          int, int, float [], float [], int *);
int c_ftcurv (int, float [], float [], int, float [], float []);
int c_ftcurvp (int, float [], float [], float, int, float [], float []);
int c_ftcurvpi (float, float, float, int, float [], float [], float *);
double c_dcapethermo(double *, double *, int, double, int, 
                     double **, double, int *, int *, int *);
extern void NGCALLF(dptlclskewt,DPTLCLSKEWT)(double *, double *, double *,
                                             double *, double *);
extern NhlErrorTypes NglGaus(int, double **output);
extern void NglVinth2p (double *dati, int, int, int, double *[], double *,
                 double *, double, double *, double *, int, int, double *,
                 double, int, int, int);
extern void c_nnseti(NhlString,int);
extern void c_nnsetrd(NhlString,double);
extern void c_nnsetc(NhlString,NhlString);

static PyObject* t_output_helper(PyObject *, PyObject *);

struct common1 {
  float pang, plat, plon;
} NGCALLF(pcmp04,PCMP04);

nglRes nglRlist;

void set_nglRes_i(int pos, int ival) {
  if (pos == 0) {
    nglRlist.nglMaximize = ival;
  }
  else if (pos == 1) {
    nglRlist.nglDraw = ival;
  }
  else if (pos == 2) {
    nglRlist.nglFrame = ival;
  }
  else if (pos == 3) {
    nglRlist.nglScale = ival;
  }
  else if (pos == 4) {
    nglRlist.nglDebug = ival;
  }
  else if (pos == 5) {
    nglRlist.nglPaperOrientation = ival;
  }
  else if (pos == 9) {
    nglRlist.nglPanelCenter = ival;
  }
  else if (pos == 10) {
    nglRlist.nglPanelRowSpec = ival;
  }
  else if (pos == 13) {
    nglRlist.nglPanelBoxes = ival;
  }
  else if (pos == 22) {
    nglRlist.nglPanelSave = ival;
  }
  else if (pos == 23) {
    nglRlist.nglSpreadColors = ival;
  }
  else if (pos == 24) {
    nglRlist.nglSpreadColorStart = ival;
  }
  else if (pos == 25) {
    nglRlist.nglSpreadColorEnd = ival;
  }
  else if (pos == 26) {
    nglRlist.nglPanelLabelBarOrientation = ival;
  }
  else if (pos == 27) {
    nglRlist.nglPanelLabelBar = ival;
  }
  else if (pos == 35) {
    nglRlist.nglPanelLabelBarPerimOn = ival;
  }
  else if (pos == 36) {
    nglRlist.nglPanelLabelBarAlignment = ival;
  }
  else if (pos == 37) {
    nglRlist.nglPanelLabelBarLabelAutoStride = ival;
  }
  else if (pos == 39) {
    nglRlist.nglPanelFigureStringsCount = ival;
  }
  else if (pos == 40) {
    nglRlist.nglPanelFigureStringsJust = ival;
  }
  else if (pos == 43) {
    nglRlist.nglPanelFigureStringsPerimOn = ival;
  }
  else if (pos == 44) {
    nglRlist.nglPanelFigureStringsBackgroundFillColor = ival;
  }
  else if (pos == 47) {
    nglRlist.nglXAxisType = ival;
  }
  else if (pos == 48) {
    nglRlist.nglYAxisType = ival;
  }
  else {
    printf("set_nglRes_i: invalid argument %d\n",pos);
  }
}

int get_nglRes_i(int pos) {
  if (pos == 0) {
    return(nglRlist.nglMaximize);
  }
  else if (pos == 1) {
    return(nglRlist.nglDraw);
  }
  else if (pos == 2) {
    return(nglRlist.nglFrame);
  }
  else if (pos == 3) {
    return(nglRlist.nglScale);
  }
  else if (pos == 4) {
    return(nglRlist.nglDebug);
  }
  else if (pos == 5) {
    return(nglRlist.nglPaperOrientation);
  }
  else if (pos == 9) {
    return(nglRlist.nglPanelCenter);
  }
  else if (pos == 10) {
    return(nglRlist.nglPanelRowSpec);
  }
  else if (pos == 13) {
    return(nglRlist.nglPanelBoxes);
  }
  else if (pos == 22) {
    return(nglRlist.nglPanelSave);
  }
  else if (pos == 23) {
    return(nglRlist.nglSpreadColors);
  }
  else if (pos == 24) {
    return(nglRlist.nglSpreadColorStart);
  }
  else if (pos == 25) {
    return(nglRlist.nglSpreadColorEnd);
  }
  else if (pos == 26) {
    return(nglRlist.nglPanelLabelBarOrientation);
  }
  else if (pos == 27) {
    return(nglRlist.nglPanelLabelBar);
  }
  else if (pos == 35) {
    return(nglRlist.nglPanelLabelBarPerimOn);
  }
  else if (pos == 36) {
    return(nglRlist.nglPanelLabelBarAlignment);
  }
  else if (pos == 37) {
    return(nglRlist.nglPanelLabelBarLabelAutoStride);
  }
  else if (pos == 39) {
    return(nglRlist.nglPanelFigureStringsCount);
  }
  else if (pos == 40) {
    return(nglRlist.nglPanelFigureStringsJust);
  }
  else if (pos == 43) {
    return(nglRlist.nglPanelFigureStringsPerimOn);
  }
  else if (pos == 44) {
    return(nglRlist.nglPanelFigureStringsBackgroundFillColor);
  }
  else if (pos == 47) {
    return(nglRlist.nglXAxisType);
  }
  else if (pos == 48) {
    return(nglRlist.nglYAxisType);
  }
  else {
    printf("get_nglRes_i: invalid argument %d\n",pos);
  }
}

void set_nglRes_f(int pos, float ival) {
  if (pos == 6) {
    nglRlist.nglPaperWidth = ival;
  }
  else if (pos == 7) {
    nglRlist.nglPaperHeight = ival;
  }
  else if (pos == 8) {
    nglRlist.nglPaperMargin = ival;
  }
  else if (pos == 11) {
    nglRlist.nglPanelXWhiteSpacePercent = ival;
  }
  else if (pos == 12) {
    nglRlist.nglPanelYWhiteSpacePercent = ival;
  }
  else if (pos == 14) {
    nglRlist.nglPanelLeft = ival;
  }
  else if (pos == 15) {
    nglRlist.nglPanelRight = ival;
  }
  else if (pos == 16) {
    nglRlist.nglPanelBottom = ival;
  }
  else if (pos == 17) {
    nglRlist.nglPanelTop = ival;
  }
  else if (pos == 18) {
    nglRlist.nglPanelInvsblTop = ival;
  }
  else if (pos == 19) {
    nglRlist.nglPanelInvsblLeft = ival;
  }
  else if (pos == 20) {
    nglRlist.nglPanelInvsblRight = ival;
  }
  else if (pos == 21) {
    nglRlist.nglPanelInvsblBottom = ival;
  }
  else if (pos == 28) {
    nglRlist.nglPanelLabelBarXF = ival;
  }
  else if (pos == 29) {
    nglRlist.nglPanelLabelBarYF = ival;
  }
  else if (pos == 30) {
    nglRlist.nglPanelLabelBarLabelFontHeightF = ival;
  }
  else if (pos == 31) {
    nglRlist.nglPanelLabelBarWidthF = ival;
  }
  else if (pos == 32) {
    nglRlist.nglPanelLabelBarHeightF = ival;
  }
  else if (pos == 33) {
    nglRlist.nglPanelLabelBarOrthogonalPosF = ival;
  }
  else if (pos == 34) {
    nglRlist.nglPanelLabelBarParallelPosF = ival;
  }
  else if (pos == 41) {
    nglRlist.nglPanelFigureStringsOrthogonalPosF = ival;
  }
  else if (pos == 42) {
    nglRlist.nglPanelFigureStringsParallelPosF = ival;
  }
  else if (pos == 45) {
    nglRlist.nglPanelFigureStringsFontHeightF = ival;
  }
  else {
    printf ("set_nglRes_f: invalid argument %d\n",pos);
  }
}

float get_nglRes_f(int pos) {
  if (pos == 6) {
    return(nglRlist.nglPaperWidth);
  }
  else if (pos == 7) {
    return(nglRlist.nglPaperHeight);
  }
  else if (pos == 8) {
    return(nglRlist.nglPaperMargin);
  }
  else if (pos == 11) {
    return(nglRlist.nglPanelXWhiteSpacePercent);
  }
  else if (pos == 12) {
    return(nglRlist.nglPanelYWhiteSpacePercent);
  }
  else if (pos == 14) {
    return(nglRlist.nglPanelLeft);
  }
  else if (pos == 15) {
    return(nglRlist.nglPanelRight);
  }
  else if (pos == 16) {
    return(nglRlist.nglPanelBottom);
  }
  else if (pos == 17) {
    return(nglRlist.nglPanelTop);
  }
  else if (pos == 18) {
    return(nglRlist.nglPanelInvsblTop);
  }
  else if (pos == 19) {
    return(nglRlist.nglPanelInvsblLeft);
  }
  else if (pos == 20) {
    return(nglRlist.nglPanelInvsblRight);
  }
  else if (pos == 21) {
    return(nglRlist.nglPanelInvsblBottom);
  }
  else if (pos == 28) {
    return(nglRlist.nglPanelLabelBarXF);
  }
  else if (pos == 29) {
    return(nglRlist.nglPanelLabelBarYF);
  }
  else if (pos == 30) {
    return(nglRlist.nglPanelLabelBarLabelFontHeightF);
  }
  else if (pos == 31) {
    return(nglRlist.nglPanelLabelBarWidthF);
  }
  else if (pos == 32) {
    return(nglRlist.nglPanelLabelBarHeightF);
  }
  else if (pos == 33) {
    return(nglRlist.nglPanelLabelBarOrthogonalPosF);
  }
  else if (pos == 34) {
    return(nglRlist.nglPanelLabelBarParallelPosF);
  }
  else if (pos == 41) {
    return(nglRlist.nglPanelFigureStringsOrthogonalPosF);
  }
  else if (pos == 42) {
    return(nglRlist.nglPanelFigureStringsParallelPosF);
  }
  else if (pos == 45) {
    return(nglRlist.nglPanelFigureStringsFontHeightF);
  }
  else {
    printf ("get_nglRes_f: invalid argument %d\n",pos);
  }
}

void set_nglRes_c (int pos, NhlString *cval) {
  if (pos == 38) {
    nglRlist.nglPanelFigureStrings = cval;    
  }
  else {
    printf ("set_nglRes_c: invalid argument %d\n",pos);
  }
}

NhlString *get_nglRes_c (int pos) {
  if (pos == 38) {
    return(nglRlist.nglPanelFigureStrings);
  }
  else {
    printf ("get_nglRes_c: invalid argument %d\n",pos);
  }
}

void set_nglRes_s (int pos, NhlString sval) {
  if (pos == 46) {
    nglRlist.nglAppResFileName = sval;    
  }
  else {
    printf ("set_nglRes_s: invalid argument %s\n",sval);
  }
}

NhlString get_nglRes_s (int pos) {
  if (pos == 46) {
    return(nglRlist.nglAppResFileName);
  }
  else {
    printf ("get_nglRes_s: invalid argument %d\n",pos);
  }
}

void set_PCMP04(int arg_num, float value)
{
  if (arg_num < 1 || arg_num > 3) {
    printf("Error in argument number in common PCMP04\n");
    exit(70);
  }
  switch(arg_num) {
    case 1:
      NGCALLF(pcmp04,PCMP04).pang = value;
    case 2:
      NGCALLF(pcmp04,PCMP04).plat = value;
    case 3:
      NGCALLF(pcmp04,PCMP04).plon = value;
  }
}

NhlErrorTypes NglGaus_p(int num, int n, int m, double *data_out[]) {
  return NglGaus(num,data_out);
}

PyObject *mapgci(float alat, float alon, float blat, float blon, int npts)
{
  float *rlati,*rloni;
  PyObject *obj1,*obj2,*status,*resultobj;

  int dims[1],ier;

  rlati = (float *) malloc(npts*sizeof(float));
  rloni = (float *) malloc(npts*sizeof(float));
  c_mapgci(alat, alon, blat, blon, npts, rlati, rloni);
  dims[0] = npts;
  obj1 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) rlati);
  obj2 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) rloni);
  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,obj1);
  resultobj = t_output_helper(resultobj,obj2);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *dcapethermo(double *penv, double *tenv, int nlvl, double lclmb, 
                      int iprnt, double tmsg)
{
  PyObject *obj1,*obj2,*obj3,*obj4,*obj5,*status,*resultobj;
  int jlcl, jlfc, jcross, dims[1];
  double cape, *tparcel;

  cape = c_dcapethermo(penv, tenv, nlvl, lclmb, iprnt, &tparcel, tmsg,
                       &jlcl, &jlfc, &jcross);                       

  dims[0] = nlvl;
  obj1 = (PyObject *) PyFloat_FromDouble(cape);
  obj2 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_DOUBLE,
                                              (char *) tparcel);
  obj3 = (PyObject *) PyInt_FromLong((long) jlcl);
  obj4 = (PyObject *) PyInt_FromLong((long) jlfc);
  obj5 = (PyObject *) PyInt_FromLong((long) jcross);

  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,obj1);
  resultobj = t_output_helper(resultobj,obj2);
  resultobj = t_output_helper(resultobj,obj3);
  resultobj = t_output_helper(resultobj,obj4);
  resultobj = t_output_helper(resultobj,obj5);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *ftcurvc(int n, float *x, float *y, int m, float *xo)
{
  float *yo;
  PyObject *obj1,*status,*resultobj;

  int dims[1],ier;

  yo = (float *) malloc(m*sizeof(float));
  ier = c_ftcurv(n,x,y,m,xo,yo);
  status = (PyObject *) PyInt_FromLong((long) ier);
  dims[0] = m;
  obj1 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) yo);
  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,status);
  resultobj = t_output_helper(resultobj,obj1);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *ftcurvpc(int n, float *x, float *y, float p, int m, float *xo)
{
  float *yo;
  PyObject *obj1,*status,*resultobj;

  int dims[1],ier;

  yo = (float *) malloc(m*sizeof(float));
  ier = c_ftcurvp(n,x,y,p,m,xo,yo);
  status = (PyObject *) PyInt_FromLong((long) ier);
  dims[0] = m;
  obj1 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) yo);
  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,status);
  resultobj = t_output_helper(resultobj,obj1);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *ftcurvpic(float xl, float xr, float p, int m, float *xi, float *yi)
{
  float yo;
  PyObject *obj1,*status,*resultobj;

  int dims[1],ier;

  ier = c_ftcurvpi(xl,xr,p,m,xi,yi,&yo);
  status = (PyObject *) PyInt_FromLong((long) ier);
  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,status);
  resultobj = t_output_helper(resultobj,
                 (PyObject *) PyFloat_FromDouble((double) yo));
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}


void natgridc(int n, float *x, float *y, float *z, int nxi, int nyi,
             float *xi, float *yi, int *ier, int nxir, int nyir, float *aout[])
{
    aout[0] = c_natgrids(n,x,y,z,nxi,nyi,xi,yi,ier);
}

int NhlGetInteger(int oid, char *name)
{
    int grlist;
    int valueI;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetInteger(grlist,name,&valueI);
    NhlGetValues(oid,grlist);

    return (valueI);
}

float NhlGetFloat(int oid, char *name)
{
    int grlist;
    float valueF;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetFloat(grlist,name,&valueF);
    NhlGetValues(oid,grlist);

    return (valueF);
}

float NhlGetDouble(int oid, char *name)
{
    int grlist;
    double valueD;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetDouble(grlist,name,&valueD);
    NhlGetValues(oid,grlist);

    return ((float) valueD);
}

NhlString NhlGetString(int oid, NhlString name)
{
    int grlist;
    NhlString valueS;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetString(grlist,name,&valueS);
    NhlGetValues(oid,grlist);

    return (valueS);
}

float *NhlGetFloatArray(int oid, char *name, int *number)
{
    int grlist;
    float *fscales;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetFloatArray(grlist,name,&fscales,number);
    NhlGetValues(oid,grlist);

    return (fscales);
}

double *NhlGetDoubleArray(int oid, char *name, int *number)
{
    int grlist;
    double *dar;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetDoubleArray(grlist,name,&dar,number);
    NhlGetValues(oid,grlist);

    return (dar);
}

int *NhlGetIntegerArray(int oid, char *name, int *number)
{
    int grlist;
    int *iar;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetIntegerArray(grlist,name,&iar,number);
    NhlGetValues(oid,grlist);

    return (iar);
}

NhlString *NhlGetStringArray(int oid, char *name, int *number)
{
    int grlist;
    NhlString *slist;

    grlist = NhlRLCreate(NhlGETRL);
    NhlRLClear(grlist);
    NhlRLGetStringArray(grlist,name,&slist,number);
    NhlGetValues(oid,grlist);

    return (slist);
}

NhlErrorTypes NhlPGetBB (int pid, float *t, float *b, float *l, float *r) {
  NhlBoundingBox *Box;
  NhlErrorTypes rv;
  Box = (NhlBoundingBox *) malloc(sizeof(NhlBoundingBox));
  rv = NhlGetBB(pid,Box);
  *t = Box->t;
  *b = Box->b;
  *l = Box->l;
  *r = Box->r;
  return(rv);
}

NhlErrorTypes NhlQNDCToData(int pid, float *x, float *y, int n, 
                            float *xout, float *yout, float xmissing, 
                            float ymissing, int ixmissing, int iymissing,
                            int *status, float *out_of_range)
{
  float *mxt, *myt;
  if (ixmissing != 1) {
    mxt = NULL;
  }
  else {
    mxt = malloc(sizeof(float));
    *mxt = xmissing;
  }
  if (iymissing != 1) {
    myt = NULL;
  }
  else {
    myt = malloc(sizeof(float));
    *myt = ymissing;
  }
  return(NhlNDCToData(pid, x, y, n, xout, yout, mxt, myt,
                      status, out_of_range));
}

PyObject *NhlPNDCToData(int pid, float *x, float *y, int n, float xmissing,
                        float ymissing, int ixmissing, int iymissing)
{
  float *xout, *yout;
  PyObject *obj1, *obj2, *nhlerr, *rstatus, *range, *resultobj;
  int dims[1],status,rval;
  float out_of_range;

  xout = (float *) malloc(n*sizeof(float));
  yout = (float *) malloc(n*sizeof(float));
  rval = (int) NhlQNDCToData(pid, x, y, n, xout, yout, xmissing,
                             ymissing, ixmissing, iymissing,
                             &status, &out_of_range);
  nhlerr = (PyObject *) PyInt_FromLong((long) rval); 
  dims[0] = n;
  obj1 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) xout);
  obj2 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) yout);
  rstatus = (PyObject *) PyInt_FromLong((long) status); 
  range = (PyObject *) PyFloat_FromDouble((double) out_of_range); 

  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,nhlerr);
  resultobj = t_output_helper(resultobj,obj1);
  resultobj = t_output_helper(resultobj,obj2);
  resultobj = t_output_helper(resultobj,rstatus);
  resultobj = t_output_helper(resultobj,range);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

NhlErrorTypes NhlQDataToNDC(int pid, float *x, float *y, int n, 
                            float *xout, float *yout, float xmissing, 
                            float ymissing, int ixmissing, int iymissing,
                            int *status, float *out_of_range)
{
  float *mxt, *myt;
  if (ixmissing != 1) {
    mxt = NULL;
  }
  else {
    mxt = malloc(sizeof(float));
    *mxt = xmissing;
  }
  if (iymissing != 1) {
    myt = NULL;
  }
  else {
    myt = malloc(sizeof(float));
    *myt = ymissing;
  }
  return(NhlDataToNDC(pid, x, y, n, xout, yout, mxt, myt,
                      status, out_of_range));
}

PyObject *NhlPDataToNDC(int pid, float *x, float *y, int n, float xmissing,
                        float ymissing, int ixmissing, int iymissing)
{
  float *xout, *yout;
  PyObject *obj1, *obj2, *nhlerr, *rstatus, *range, *resultobj;
  int dims[1],status,rval;
  float out_of_range;

  xout = (float *) malloc(n*sizeof(float));
  yout = (float *) malloc(n*sizeof(float));
  rval = (int) NhlQDataToNDC(pid, x, y, n, xout, yout, xmissing,
                             ymissing, ixmissing, iymissing,
                             &status, &out_of_range);
  nhlerr = (PyObject *) PyInt_FromLong((long) rval); 
  dims[0] = n;
  obj1 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) xout);
  obj2 = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,
                                              (char *) yout);
  rstatus = (PyObject *) PyInt_FromLong((long) status); 
  range = (PyObject *) PyFloat_FromDouble((double) out_of_range); 

  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,nhlerr);
  resultobj = t_output_helper(resultobj,obj1);
  resultobj = t_output_helper(resultobj,obj2);
  resultobj = t_output_helper(resultobj,rstatus);
  resultobj = t_output_helper(resultobj,range);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *NhlGetMDFloatArray(int pid, char *name) {
  PyObject *obj1, *nhlerr, *resultobj;
  int num_dims, *len_dims, grlist;
  float *bptr;
  NhlErrorTypes rval;

  grlist = NhlRLCreate(NhlGETRL);
  NhlRLClear(grlist);
  rval = NhlRLGetMDFloatArray(grlist,name,&bptr,&num_dims,&len_dims);
  NhlGetValues(pid,grlist);

  obj1 = (PyObject *) PyArray_FromDimsAndData(num_dims,len_dims,PyArray_FLOAT,
                                              (char *) bptr);
  nhlerr = (PyObject *) PyInt_FromLong((long) rval); 

  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,nhlerr);
  resultobj = t_output_helper(resultobj,obj1);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *NhlGetMDDoubleArray(int pid, char *name) {
  PyObject *obj1, *nhlerr, *resultobj;
  int num_dims, *len_dims, grlist;
  double *bptr;
  NhlErrorTypes rval;

  grlist = NhlRLCreate(NhlGETRL);
  NhlRLClear(grlist);
  rval = NhlRLGetMDDoubleArray(grlist,name,&bptr,&num_dims,&len_dims);
  NhlGetValues(pid,grlist);

  obj1 = (PyObject *) PyArray_FromDimsAndData(num_dims,len_dims,PyArray_DOUBLE,
                                              (char *) bptr);
  nhlerr = (PyObject *) PyInt_FromLong((long) rval); 

  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,nhlerr);
  resultobj = t_output_helper(resultobj,obj1);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

PyObject *NhlGetMDIntegerArray(int pid, char *name) {
  PyObject *obj1, *nhlerr, *resultobj;
  int num_dims, *len_dims, grlist;
  int *bptr;
  NhlErrorTypes rval;

  grlist = NhlRLCreate(NhlGETRL);
  NhlRLClear(grlist);
  rval = NhlRLGetMDIntegerArray(grlist,name,&bptr,&num_dims,&len_dims);
  NhlGetValues(pid,grlist);

  obj1 = (PyObject *) PyArray_FromDimsAndData(num_dims,len_dims,PyArray_INT,
                                              (char *) bptr);
  nhlerr = (PyObject *) PyInt_FromLong((long) rval); 

  resultobj = Py_None;
  resultobj = t_output_helper(resultobj,nhlerr);
  resultobj = t_output_helper(resultobj,obj1);
  if (resultobj == Py_None) Py_INCREF(Py_None);
  return resultobj;
}

float *d2f(int isize, double *darray) {
  float *farray;
  int i;
  farray = (float *) malloc(isize*sizeof(float));
  for (i = 0; i < isize; i++) {
    farray[i] = (float) darray[i];
  }
  return (farray);
}

void gendat (int idim, int m, int n, int mlow, int mhgh, 
             float dlow, float dhgh, float *data)
{
/*
 * This is a routine to generate test data for two-dimensional graphics
 * routines.  Given an array "DATA", dimensioned "IDIM x 1", it fills
 * the sub-array ((DATA(I,J),I=1,M),J=1,N) with a two-dimensional field
 * of data having approximately "MLOW" lows and "MHGH" highs, a minimum
 * value of exactly "DLOW" and a maximum value of exactly "DHGH".
 *
 * "MLOW" and "MHGH" are each forced to be greater than or equal to 1
 * and less than or equal to 25.
 *
 * The function used is a sum of exponentials.
 */
    float ccnt[3][50], fovm, fovn, dmin, dmax, temp;
    extern float fran();
    int nlow, nhgh, ncnt, i, j, k, ii;

    fovm=9./(float)m;
    fovn=9./(float)n;

    nlow=max(1,min(25,mlow));
    nhgh=max(1,min(25,mhgh));
    ncnt=nlow+nhgh;

    for( k=1; k <= ncnt; k++ ) {
        ccnt[0][k-1]=1.+((float)m-1.)*fran();
        ccnt[1][k-1]=1.+((float)n-1.)*fran();
        if (k <= nlow) {
            ccnt[2][k-1]= -1.;
        }
        else {
            ccnt[2][k-1] = 1.;
        }
    }

    dmin =  1.e36;
    dmax = -1.e36;
    ii = 0;
    for( j = 1; j <= n; j++ ) {
        for( i = 1; i <= m; i++ ) {
            data[ii]=.5*(dlow+dhgh);
            for( k = 1; k <= ncnt; k++ ) {
                temp = -(pow2((fovm*((float)(i)-ccnt[0][k-1])))+
                         pow2(fovn*((float)(j)-ccnt[1][k-1])));
                if (temp >= -20.) data[ii]=data[ii]+.5*(dhgh-dlow)
                                           *ccnt[2][k-1]*exp(temp);
            }
            dmin=min(dmin,data[ii]);
            dmax=max(dmax,data[ii]);
            ii++;
        }
    }

    for( j = 0; j < m*n; j++ ) {
        data[j]=(data[j]-dmin)/(dmax-dmin)*(dhgh-dlow)+dlow;
    }
}

float rseq[] = { .749, .973, .666, .804, .081, .483, .919, .903, .951, .960,
   .039, .269, .270, .756, .222, .478, .621, .063, .550, .798, .027, .569,
   .149, .697, .451, .738, .508, .041, .266, .249, .019, .191, .266, .625,
   .492, .940, .508, .406, .972, .311, .757, .378, .299, .536, .619, .844,
   .342, .295, .447, .499, .688, .193, .225, .520, .954, .749, .997, .693,
   .217, .273, .961, .948, .902, .104, .495, .257, .524, .100, .492, .347,
   .981, .019, .225, .806, .678, .710, .235, .600, .994, .758, .682, .373,
   .009, .469, .203, .730, .588, .603, .213, .495, .884, .032, .185, .127,
   .010, .180, .689, .354, .372, .429 };

float fran()
{
    static int iseq = 0;
    iseq = (iseq % 100) + 1;
    return(rseq[iseq-1]);
}

void bndary()
{
/*
 * Draw a line showing where the edge of the plotter frame is.
 */
    c_plotif (0.,0.,0);
    c_plotif (1.,0.,1);
    c_plotif (1.,1.,1);
    c_plotif (0.,1.,1);
    c_plotif (0.,0.,1);
    c_plotif (0.,0.,2);
}



static int *new_intp() { 
  return (int *) calloc(1,sizeof(int)); 
}

static int *copy_intp(int value) { 
  int *self = (int *) calloc(1,sizeof(int));
  *self = value;
  return self; 
}

static void delete_intp(int *self) { 
  if (self) free(self); 
}

static void intp_assign(int *self, int value) {
  *self = value;
}

static int intp_value(int *self) {
  return *self;
}


static float *new_floatArray(int nelements) { 
  return (float *) calloc(nelements,sizeof(float)); 
}

static void delete_floatArray(float *ary) { 
  free(ary); 
}

static float floatArray_getitem(float *ary, int index) {
    return ary[index];
}
static void floatArray_setitem(float *ary, int index, float value) {
    ary[index] = value;
}


#include <Numeric/arrayobject.h>

extern char const *_NGGetNCARGEnv(char const *);
extern void NhlInitialize();
extern void NhlClose();
extern void NhlRLClear(int);
extern NhlErrorTypes NhlSetValues(int,int);
extern NhlErrorTypes NhlRLSetString(int,NhlString,NhlString);
extern NhlErrorTypes NhlRLSetFloat(int,NhlString,float);
extern NhlErrorTypes NhlRLSetDouble(int,NhlString,double);
extern NhlErrorTypes NhlRLSetInteger(int,NhlString,int);
extern NhlErrorTypes NhlNDCPolyline(int,int,float *,float *,int);
extern NhlErrorTypes NhlNDCPolymarker(int,int,float *,float *,int);
extern NhlErrorTypes NhlNDCPolygon(int,int,float *,float *,int);
extern NhlErrorTypes NhlDataPolyline(int,int,float *,float *,int);
extern NhlErrorTypes NhlDataPolymarker(int,int,float *,float *,int);
extern NhlErrorTypes NhlDataPolygon(int,int,float *,float *,int);
extern NhlErrorTypes NhlDraw(int);
extern NhlErrorTypes NhlFreeColor(int,int);
extern int NhlGetGksCi(int,int);
extern int NhlGetWorkspaceObjectId();
extern NhlBoolean NhlIsAllocatedColor(int,int);
extern NhlBoolean NhlIsApp(int);
extern NhlBoolean NhlIsDataComm(int);
extern NhlBoolean NhlIsDataItem(int);
extern NhlBoolean NhlIsDataSpec(int);
extern NhlBoolean NhlRLIsSet(int,NhlString);
extern void NhlRLUnSet(int,NhlString);
extern NhlBoolean NhlIsTransform(int);
extern NhlBoolean NhlIsView(int);
extern NhlBoolean NhlIsWorkstation(int);
extern char const *NhlName(int);
extern int NhlNewColor(int,float,float,float);
extern NhlErrorTypes NhlSetColor(int,int,float,float,float);
extern NhlErrorTypes NhlUpdateData(int);
extern NhlErrorTypes NhlUpdateWorkstation(int);
extern void NhlOpen();
extern NhlErrorTypes NhlCreate(int *,char const *,NhlClass,int,int);

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

extern int NhlRLCreate(NhlRLType);
extern NhlErrorTypes NhlFrame(int);
extern NhlErrorTypes NhlDestroy(int);
extern NhlErrorTypes NhlRLSetMDIntegerArray(int,char *,int *,int,int *);
extern NhlErrorTypes NhlRLSetMDDoubleArray(int,char *,double *,int,int *);
extern NhlErrorTypes NhlRLSetMDFloatArray(int,char *,float *,int,int *);
extern NhlErrorTypes NhlRLSetFloatArray(int,char *,float *,int);
extern NhlErrorTypes NhlRLSetIntegerArray(int,char *,int *,int);
extern NhlErrorTypes NhlRLSetStringArray(int,NhlString,NhlString *,int);
extern NhlErrorTypes NhlGetValues(int,int);
extern float NhlGetFloat(int,char *);
extern float *NhlGetFloatArray(int,char *,int *);
extern int NhlGetInteger(int,char *);
extern int *NhlGetIntegerArray(int,char *,int *);
extern float NhlGetDouble(int,char *);
extern double *NhlGetDoubleArray(int,char *,int *);
extern NhlErrorTypes NhlAddOverlay(int,int,int);
extern NhlErrorTypes NhlClearWorkstation(int);
extern NhlErrorTypes NhlRemoveAnnotation(int,int);
extern int NhlAddAnnotation(int,int);
extern int NhlAppGetDefaultParentId();
extern char const *NhlClassName(int);
extern NhlString NhlGetString(int,NhlString);
extern int NhlAddData(int,NhlString,int);
extern NhlErrorTypes NhlRemoveData(int,NhlString,int);
extern NhlErrorTypes NhlRemoveOverlay(int,int,NhlBoolean);
extern NhlString *NhlGetStringArray(int,char *,int *);
extern void NhlRLDestroy(int);
extern int NhlGetNamedColorIndex(int,char const *);
extern NhlErrorTypes NhlGetBB(int,NhlBoundingBox *);
extern NhlErrorTypes NhlChangeWorkstation(int,int);
extern NhlErrorTypes NhlPGetBB(int,float *,float *,float *,float *);
extern PyObject *NhlPNDCToData(int,float *,float *,int,float,float,int,int);
extern PyObject *NhlPDataToNDC(int,float *,float *,int,float,float,int,int);
extern PyObject *NhlGetMDFloatArray(int,char *);
extern PyObject *NhlGetMDDoubleArray(int,char *);
extern PyObject *NhlGetMDIntegerArray(int,char *);
extern NhlClass NhlPAppClass();
extern NhlClass NhlPNcgmWorkstationClass();
extern NhlClass NhlPXWorkstationClass();
extern NhlClass NhlPPSWorkstationClass();
extern NhlClass NhlPPDFWorkstationClass();
extern NhlClass NhlPLogLinPlotClass();
extern NhlClass NhlPGraphicStyleClass();
extern NhlClass NhlPScalarFieldClass();
extern NhlClass NhlPContourPlotClass();
extern NhlClass NhlPtextItemClass();
extern NhlClass NhlPscalarFieldClass();
extern NhlClass NhlPmapPlotClass();
extern NhlClass NhlPcoordArraysClass();
extern NhlClass NhlPxyPlotClass();
extern NhlClass NhlPtickMarkClass();
extern NhlClass NhlPtitleClass();
extern NhlClass NhlPlabelBarClass();
extern NhlClass NhlPlegendClass();
extern NhlClass NhlPvectorFieldClass();
extern NhlClass NhlPvectorPlotClass();
extern NhlClass NhlPstreamlinePlotClass();
extern char const *NGGetNCARGEnv(char const *);
extern void set_PCMP04(int,float);
extern void gendat(int,int,int,int,int,float,float,float *);
extern void gactivate_ws(int);
extern void gdeactivate_ws(int);
extern void bndary();
extern void c_plotif(float,float,int);
extern void c_cpseti(NhlString,int);
extern void c_cpsetr(NhlString,float);
extern void c_pcseti(NhlString,int);
extern void c_pcsetr(NhlString,float);
extern void c_set(float,float,float,float,float,float,float,float,int);
extern void c_cprect(float *,int,int,int,float *,int,int *,int);
extern void c_cpcldr(float *,float *,int *);
extern void c_plchhq(float,float,NhlString,float,float,float);
extern int open_wks_wrap(char const *,char const *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId labelbar_ndc_wrap(int,int,NhlString *,int,void *,void *,char const *,char const *,ResInfo *,nglRes *);
extern nglPlotId legend_ndc_wrap(int,int,NhlString *,int,void *,void *,char const *,char const *,ResInfo *,nglRes *);
extern nglPlotId contour_wrap(int,void *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId map_wrap(int,ResInfo *,nglRes *);
extern nglPlotId contour_map_wrap(int,void *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId xy_wrap(int,void *,void *,char const *,char const *,int,int *,int,int *,int,int,void *,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId y_wrap(int,void *,char const *,int,int *,int,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId vector_wrap(int,void *,void *,char const *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,int,void *,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId vector_map_wrap(int,void *,void *,char const *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,int,void *,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId vector_scalar_wrap(int,void *,void *,void *,char const *,char const *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,int,int,void *,void *,void *,ResInfo *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId vector_scalar_map_wrap(int,void *,void *,void *,char const *,char const *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,int,int,void *,void *,void *,ResInfo *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId streamline_wrap(int,void *,void *,char const *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,int,void *,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId streamline_map_wrap(int,void *,void *,char const *,char const *,int,int,int,void *,char const *,int,void *,char const *,int,int,void *,void *,ResInfo *,ResInfo *,ResInfo *,nglRes *);
extern nglPlotId text_ndc_wrap(int,NhlString,void *,void *,char const *,char const *,ResInfo *,nglRes *);
extern nglPlotId text_wrap(int,nglPlotId *,NhlString,void *,void *,char const *,char const *,ResInfo *,nglRes *);
extern nglPlotId add_text_wrap(int,nglPlotId *,NhlString,void *,void *,char const *,char const *,ResInfo *,ResInfo *,nglRes *);
extern void poly_wrap(int,nglPlotId *,void *,void *,char const *,char const *,int,int,int,void *,void *,NhlPolyType,ResInfo *,nglRes *);
extern nglPlotId add_poly_wrap(int,nglPlotId *,void *,void *,char const *,char const *,int,int,int,void *,void *,NhlPolyType,ResInfo *,nglRes *);
extern PyObject *mapgci(float,float,float,float,int);
extern PyObject *dcapethermo(double *,double *,int,double,int,double);
extern void draw_colormap_wrap(int);
extern void natgridc(int,float *,float *,float *,int,int,float *,float *,int *,int,int,float *[]);
extern PyObject *ftcurvc(int,float *,float *,int,float *);
extern PyObject *ftcurvpc(int,float *,float *,float,int,float *);
extern PyObject *ftcurvpic(float,float,float,int,float *,float *);
extern void c_rgbhls(float,float,float,float *,float *,float *);
extern void c_hlsrgb(float,float,float,float *,float *,float *);
extern void c_rgbhsv(float,float,float,float *,float *,float *);
extern void c_hsvrgb(float,float,float,float *,float *,float *);
extern void c_rgbyiq(float,float,float,float *,float *,float *);
extern void c_yiqrgb(float,float,float,float *,float *,float *);
extern void c_wmbarbp(int,float,float,float,float);
extern void c_wmsetip(NhlString,int);
extern void c_wmsetrp(NhlString,float);
extern void c_wmsetcp(NhlString,NhlString);
extern int c_wmgetip(NhlString);
extern float c_wmgetrp(NhlString);
extern NhlString c_wmgetcp(NhlString);
extern void c_nnseti(NhlString,int);
extern void c_nnsetrd(NhlString,double);
extern void c_nnsetc(NhlString,NhlString);
extern void c_nngeti(NhlString,int *);
extern void c_nngetrd(NhlString,double *);
extern NhlString c_nngetcp(NhlString);
extern double c_dgcdist(double,double,double,double,int);
extern double c_dcapethermo(double *,double *,int,double,int,double **,double,int *,int *,int *);
extern void c_dptlclskewt(double,double,double,double *,double *);
extern double c_dtmrskewt(double,double);
extern double c_dtdaskewt(double,double);
extern double c_dsatlftskewt(double,double);
extern double c_dshowalskewt(double *,double *,double *,int);
extern double c_dpwskewt(double *,double *,int);
extern void *pvoid();
extern void set_nglRes_i(int,int);
extern int get_nglRes_i(int);
extern void set_nglRes_f(int,float);
extern float get_nglRes_f(int);
extern void set_nglRes_c(int,NhlString *);
extern NhlString *get_nglRes_c(int);
extern void set_nglRes_s(int,NhlString);
extern NhlString get_nglRes_s(int);
extern NhlErrorTypes NglGaus_p(int,int,int,double *[]);
extern void NglVinth2p(double *,int,int,int,double *[],double *,double *,double,double *,double *,int,int,double *,double,int,int,int);
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_new_intp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_intp")) goto fail;
    result = (int *)new_intp();
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_int, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_copy_intp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:copy_intp",&arg1)) goto fail;
    result = (int *)copy_intp(arg1);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_int, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_intp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int *arg1 = (int *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_intp",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_int,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    delete_intp(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_intp_assign(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int *arg1 = (int *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:intp_assign",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_int,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    intp_assign(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_intp_value(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int *arg1 = (int *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:intp_value",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_int,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)intp_value(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_floatArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:new_floatArray",&arg1)) goto fail;
    result = (float *)new_floatArray(arg1);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_floatArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_floatArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    delete_floatArray(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_floatArray_getitem(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:floatArray_getitem",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float)floatArray_getitem(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_floatArray_setitem(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    float arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oif:floatArray_setitem",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    floatArray_setitem(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}




static PyObject *_wrap__NGGetNCARGEnv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:_NGGetNCARGEnv",&arg1)) goto fail;
    result = (char *)_NGGetNCARGEnv((char const *)arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlInitialize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlInitialize")) goto fail;
    NhlInitialize();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlClose(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlClose")) goto fail;
    NhlClose();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLClear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlRLClear",&arg1)) goto fail;
    NhlRLClear(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlSetValues(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:NhlSetValues",&arg1,&obj1)) goto fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj1)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj1);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj1, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg2 = rlist;
    }
    result = (int)NhlSetValues(arg1,arg2);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetString(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    NhlString arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iss:NhlRLSetString",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlRLSetString(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetFloat(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    float arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isf:NhlRLSetFloat",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlRLSetFloat(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetDouble(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    double arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isd:NhlRLSetDouble",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlRLSetDouble(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetInteger(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    int arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isi:NhlRLSetInteger",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlRLSetInteger(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlNDCPolyline(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOOi:NhlNDCPolyline",&arg1,&arg2,&obj2,&obj3,&arg5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlNDCPolyline(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlNDCPolymarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOOi:NhlNDCPolymarker",&arg1,&arg2,&obj2,&obj3,&arg5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlNDCPolymarker(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlNDCPolygon(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOOi:NhlNDCPolygon",&arg1,&arg2,&obj2,&obj3,&arg5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlNDCPolygon(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlDataPolyline(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOOi:NhlDataPolyline",&arg1,&arg2,&obj2,&obj3,&arg5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlDataPolyline(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlDataPolymarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOOi:NhlDataPolymarker",&arg1,&arg2,&obj2,&obj3,&arg5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlDataPolymarker(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlDataPolygon(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOOi:NhlDataPolygon",&arg1,&arg2,&obj2,&obj3,&arg5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlDataPolygon(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlDraw(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlDraw",&arg1)) goto fail;
    result = (int)NhlDraw(arg1);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlFreeColor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:NhlFreeColor",&arg1,&arg2)) goto fail;
    result = (int)NhlFreeColor(arg1,arg2);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetGksCi(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:NhlGetGksCi",&arg1,&arg2)) goto fail;
    result = (int)NhlGetGksCi(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetWorkspaceObjectId(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlGetWorkspaceObjectId")) goto fail;
    result = (int)NhlGetWorkspaceObjectId();
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsAllocatedColor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:NhlIsAllocatedColor",&arg1,&arg2)) goto fail;
    result = (NhlBoolean)NhlIsAllocatedColor(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsApp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsApp",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsApp(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsDataComm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsDataComm",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsDataComm(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsDataItem(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsDataItem",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsDataItem(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsDataSpec(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsDataSpec",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsDataSpec(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLIsSet(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlRLIsSet",&arg1,&arg2)) goto fail;
    result = (NhlBoolean)NhlRLIsSet(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLUnSet(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlRLUnSet",&arg1,&arg2)) goto fail;
    NhlRLUnSet(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsTransform(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsTransform",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsTransform(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsView(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsView",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsView(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlIsWorkstation(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoolean result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlIsWorkstation",&arg1)) goto fail;
    result = (NhlBoolean)NhlIsWorkstation(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlName",&arg1)) goto fail;
    result = (char *)NhlName(arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlNewColor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ifff:NhlNewColor",&arg1,&arg2,&arg3,&arg4)) goto fail;
    result = (int)NhlNewColor(arg1,arg2,arg3,arg4);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlSetColor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iifff:NhlSetColor",&arg1,&arg2,&arg3,&arg4,&arg5)) goto fail;
    result = (int)NhlSetColor(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlUpdateData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlUpdateData",&arg1)) goto fail;
    result = (int)NhlUpdateData(arg1);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlUpdateWorkstation(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlUpdateWorkstation",&arg1)) goto fail;
    result = (int)NhlUpdateWorkstation(arg1);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlOpen(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlOpen")) goto fail;
    NhlOpen();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlCreate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int *arg1 = (int *) 0 ;
    char *arg2 ;
    NhlClass arg3 ;
    int arg4 ;
    int arg5 ;
    int result;
    int temp1 ;
    NhlClass *argp3 ;
    PyObject * obj1 = 0 ;
    
    arg1 = &temp1;
    if(!PyArg_ParseTuple(args,(char *)"sOii:NhlCreate",&arg2,&obj1,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp3, SWIGTYPE_p_NhlClass,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg3 = *argp3; 
    result = (int)NhlCreate(arg1,(char const *)arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    {
        PyObject *o = PyInt_FromLong((long) (*arg1));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLCreate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlRLCreate",&arg1)) goto fail;
    result = (int)NhlRLCreate((NhlRLType )arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlFrame(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlFrame",&arg1)) goto fail;
    result = (int)NhlFrame(arg1);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlDestroy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlDestroy",&arg1)) goto fail;
    result = (int)NhlDestroy(arg1);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetMDIntegerArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int *arg3 = (int *) 0 ;
    int arg4 ;
    int *arg5 = (int *) 0 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOiO:NhlRLSetMDIntegerArray",&arg1,&arg2,&obj2,&arg4,&obj4)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_INT,0,0);
        arg3 = (int *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_INT,0,0);
        arg5 = (int *) arr->data;
    }
    result = (int)NhlRLSetMDIntegerArray(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetMDDoubleArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    double *arg3 = (double *) 0 ;
    int arg4 ;
    int *arg5 = (int *) 0 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOiO:NhlRLSetMDDoubleArray",&arg1,&arg2,&obj2,&arg4,&obj4)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_INT,0,0);
        arg5 = (int *) arr->data;
    }
    result = (int)NhlRLSetMDDoubleArray(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetMDFloatArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    int *arg5 = (int *) 0 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOiO:NhlRLSetMDFloatArray",&arg1,&arg2,&obj2,&arg4,&obj4)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_INT,0,0);
        arg5 = (int *) arr->data;
    }
    result = (int)NhlRLSetMDFloatArray(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetFloatArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    int result;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOi:NhlRLSetFloatArray",&arg1,&arg2,&obj2,&arg4)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (int)NhlRLSetFloatArray(arg1,arg2,arg3,arg4);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetIntegerArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int *arg3 = (int *) 0 ;
    int arg4 ;
    int result;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOi:NhlRLSetIntegerArray",&arg1,&arg2,&obj2,&arg4)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_INT,0,0);
        arg3 = (int *) arr->data;
    }
    result = (int)NhlRLSetIntegerArray(arg1,arg2,arg3,arg4);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLSetStringArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    NhlString *arg3 = (NhlString *) 0 ;
    int arg4 ;
    int result;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOi:NhlRLSetStringArray",&arg1,&arg2,&obj2,&arg4)) goto fail;
    {
        if (PyList_Check(obj2)) {
            int size = PyList_Size(obj2);
            int i = 0;
            arg3 = (NhlString *) malloc((size+1)*sizeof(char *));
            if (size == 0) {
                arg3[0] = 0;
            }
            else {
                for (i = 0; i < size; i++) {
                    PyObject *o = PyList_GetItem(obj2,i);
                    if (PyString_Check(o)) {
                        arg3[i] = PyString_AsString(PyList_GetItem(obj2,i));
                    }
                    else {
                        PyErr_SetString(PyExc_TypeError,"List must contain strings");
                        free (arg3);
                        return NULL;
                    }
                }
            }
        } else {
            PyErr_SetString(PyExc_TypeError,"Not a list");
            return NULL;
        }
    }
    result = (int)NhlRLSetStringArray(arg1,arg2,arg3,arg4);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetValues(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:NhlGetValues",&arg1,&obj1)) goto fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj1)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj1);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj1, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg2 = rlist;
    }
    result = (int)NhlGetValues(arg1,arg2);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetFloat(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    float result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetFloat",&arg1,&arg2)) goto fail;
    result = (float)NhlGetFloat(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetFloatArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int *arg3 = (int *) 0 ;
    float *result;
    int tempx3 ;
    
    {
        arg3 = &tempx3;
    }
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetFloatArray",&arg1,&arg2)) goto fail;
    result = (float *)NhlGetFloatArray(arg1,arg2,arg3);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float, 0);
    {
        int dims[1];
        dims[0] = *(arg3);
        resultobj = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,(char *) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetInteger(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetInteger",&arg1,&arg2)) goto fail;
    result = (int)NhlGetInteger(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetIntegerArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int *arg3 = (int *) 0 ;
    int *result;
    int tempx3 ;
    
    {
        arg3 = &tempx3;
    }
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetIntegerArray",&arg1,&arg2)) goto fail;
    result = (int *)NhlGetIntegerArray(arg1,arg2,arg3);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_int, 0);
    {
        int dims[1];
        dims[0] = *(arg3);
        resultobj = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_INT,(char *) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetDouble(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    float result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetDouble",&arg1,&arg2)) goto fail;
    result = (float)NhlGetDouble(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetDoubleArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int *arg3 = (int *) 0 ;
    double *result;
    int tempx3 ;
    
    {
        arg3 = &tempx3;
    }
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetDoubleArray",&arg1,&arg2)) goto fail;
    result = (double *)NhlGetDoubleArray(arg1,arg2,arg3);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_double, 0);
    {
        int dims[1];
        dims[0] = *(arg3);
        resultobj = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_DOUBLE,(char *) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlAddOverlay(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iii:NhlAddOverlay",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlAddOverlay(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlClearWorkstation(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlClearWorkstation",&arg1)) goto fail;
    result = (int)NhlClearWorkstation(arg1);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRemoveAnnotation(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:NhlRemoveAnnotation",&arg1,&arg2)) goto fail;
    result = (int)NhlRemoveAnnotation(arg1,arg2);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlAddAnnotation(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:NhlAddAnnotation",&arg1,&arg2)) goto fail;
    result = (int)NhlAddAnnotation(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlAppGetDefaultParentId(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlAppGetDefaultParentId")) goto fail;
    result = (int)NhlAppGetDefaultParentId();
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlClassName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlClassName",&arg1)) goto fail;
    result = (char *)NhlClassName(arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetString(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    NhlString result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetString",&arg1,&arg2)) goto fail;
    result = (NhlString)NhlGetString(arg1,arg2);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlAddData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    int arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isi:NhlAddData",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlAddData(arg1,arg2,arg3);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRemoveData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    int arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isi:NhlRemoveData",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlRemoveData(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRemoveOverlay(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    NhlBoolean arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iii:NhlRemoveOverlay",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NhlRemoveOverlay(arg1,arg2,arg3);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetStringArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int *arg3 = (int *) 0 ;
    NhlString *result;
    int tempx3 ;
    
    
    arg3 = &tempx3;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetStringArray",&arg1,&arg2)) goto fail;
    result = (NhlString *)NhlGetStringArray(arg1,arg2,arg3);
    
    {
        int i;
        PyObject *rlist;
        rlist = PyList_New(*arg3);
        for (i = 0; i < *arg3; i++) {
            PyList_SetItem(rlist,i,PyString_FromString((char *)result[i]));
        }
        resultobj = rlist;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlRLDestroy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    
    if(!PyArg_ParseTuple(args,(char *)"i:NhlRLDestroy",&arg1)) goto fail;
    NhlRLDestroy(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetNamedColorIndex(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetNamedColorIndex",&arg1,&arg2)) goto fail;
    result = (int)NhlGetNamedColorIndex(arg1,(char const *)arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetBB(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlBoundingBox *arg2 = (NhlBoundingBox *) 0 ;
    int result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:NhlGetBB",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NhlBoundingBox,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)NhlGetBB(arg1,arg2);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlChangeWorkstation(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:NhlChangeWorkstation",&arg1,&arg2)) goto fail;
    result = (int)NhlChangeWorkstation(arg1,arg2);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPGetBB(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *arg2 = (float *) 0 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    int result;
    float temp2 ;
    float temp3 ;
    float temp4 ;
    float temp5 ;
    
    arg2 = &temp2;
    arg3 = &temp3;
    arg4 = &temp4;
    arg5 = &temp5;
    if(!PyArg_ParseTuple(args,(char *)"i:NhlPGetBB",&arg1)) goto fail;
    result = (int)NhlPGetBB(arg1,arg2,arg3,arg4,arg5);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg2));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg3));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPNDCToData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *arg2 = (float *) 0 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    float arg5 ;
    float arg6 ;
    int arg7 ;
    int arg8 ;
    PyObject *result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOiffii:NhlPNDCToData",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg2 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (PyObject *)NhlPNDCToData(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPDataToNDC(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *arg2 = (float *) 0 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    float arg5 ;
    float arg6 ;
    int arg7 ;
    int arg8 ;
    PyObject *result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOiffii:NhlPDataToNDC",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg2 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (PyObject *)NhlPDataToNDC(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetMDFloatArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetMDFloatArray",&arg1,&arg2)) goto fail;
    result = (PyObject *)NhlGetMDFloatArray(arg1,arg2);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetMDDoubleArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetMDDoubleArray",&arg1,&arg2)) goto fail;
    result = (PyObject *)NhlGetMDDoubleArray(arg1,arg2);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlGetMDIntegerArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:NhlGetMDIntegerArray",&arg1,&arg2)) goto fail;
    result = (PyObject *)NhlGetMDIntegerArray(arg1,arg2);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPAppClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPAppClass")) goto fail;
    result = NhlPAppClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPNcgmWorkstationClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPNcgmWorkstationClass")) goto fail;
    result = NhlPNcgmWorkstationClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPXWorkstationClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPXWorkstationClass")) goto fail;
    result = NhlPXWorkstationClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPPSWorkstationClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPPSWorkstationClass")) goto fail;
    result = NhlPPSWorkstationClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPPDFWorkstationClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPPDFWorkstationClass")) goto fail;
    result = NhlPPDFWorkstationClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPLogLinPlotClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPLogLinPlotClass")) goto fail;
    result = NhlPLogLinPlotClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPGraphicStyleClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPGraphicStyleClass")) goto fail;
    result = NhlPGraphicStyleClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPScalarFieldClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPScalarFieldClass")) goto fail;
    result = NhlPScalarFieldClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPContourPlotClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPContourPlotClass")) goto fail;
    result = NhlPContourPlotClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPtextItemClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPtextItemClass")) goto fail;
    result = NhlPtextItemClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPscalarFieldClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPscalarFieldClass")) goto fail;
    result = NhlPscalarFieldClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPmapPlotClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPmapPlotClass")) goto fail;
    result = NhlPmapPlotClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPcoordArraysClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPcoordArraysClass")) goto fail;
    result = NhlPcoordArraysClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPxyPlotClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPxyPlotClass")) goto fail;
    result = NhlPxyPlotClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPtickMarkClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPtickMarkClass")) goto fail;
    result = NhlPtickMarkClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPtitleClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPtitleClass")) goto fail;
    result = NhlPtitleClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPlabelBarClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPlabelBarClass")) goto fail;
    result = NhlPlabelBarClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPlegendClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPlegendClass")) goto fail;
    result = NhlPlegendClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPvectorFieldClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPvectorFieldClass")) goto fail;
    result = NhlPvectorFieldClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPvectorPlotClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPvectorPlotClass")) goto fail;
    result = NhlPvectorPlotClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NhlPstreamlinePlotClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlClass result;
    
    if(!PyArg_ParseTuple(args,(char *)":NhlPstreamlinePlotClass")) goto fail;
    result = NhlPstreamlinePlotClass();
    
    {
        NhlClass * resultptr;
        resultptr = (NhlClass *) malloc(sizeof(NhlClass));
        memmove(resultptr, &result, sizeof(NhlClass));
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NhlClass, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NGGetNCARGEnv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:NGGetNCARGEnv",&arg1)) goto fail;
    result = (char *)NGGetNCARGEnv((char const *)arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_set_PCMP04(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"if:set_PCMP04",&arg1,&arg2)) goto fail;
    set_PCMP04(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gendat(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    float arg6 ;
    float arg7 ;
    float *arg8 = (float *) 0 ;
    float tempx8 ;
    PyObject * obj0 = 0 ;
    
    
    arg8 = &tempx8;
    
    if(!PyArg_ParseTuple(args,(char *)"Oiiiiff:gendat",&obj0,&arg2,&arg3,&arg4,&arg5,&arg6,&arg7)) goto fail;
    
    arg1 = (int) PyInt_AsLong(obj0);
    arg8 = (float *) malloc(arg1*sizeof(float));
    
    gendat(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int dims[1];
        dims[0] = arg1;
        resultobj = (PyObject *) PyArray_FromDimsAndData(1,dims,PyArray_FLOAT,(char *) arg8);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gactivate_ws(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    
    if(!PyArg_ParseTuple(args,(char *)"i:gactivate_ws",&arg1)) goto fail;
    gactivate_ws(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gdeactivate_ws(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    
    if(!PyArg_ParseTuple(args,(char *)"i:gdeactivate_ws",&arg1)) goto fail;
    gdeactivate_ws(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_bndary(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":bndary")) goto fail;
    bndary();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_plotif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    int arg3 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ffi:c_plotif",&arg1,&arg2,&arg3)) goto fail;
    c_plotif(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_cpseti(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    int arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"si:c_cpseti",&arg1,&arg2)) goto fail;
    c_cpseti(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_cpsetr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    float arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sf:c_cpsetr",&arg1,&arg2)) goto fail;
    c_cpsetr(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_pcseti(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    int arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"si:c_pcseti",&arg1,&arg2)) goto fail;
    c_pcseti(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_pcsetr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    float arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sf:c_pcsetr",&arg1,&arg2)) goto fail;
    c_pcsetr(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    int arg9 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ffffffffi:c_set",&arg1,&arg2,&arg3,&arg4,&arg5,&arg6,&arg7,&arg8,&arg9)) goto fail;
    c_set(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_cprect(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    float *arg5 = (float *) 0 ;
    int arg6 ;
    int *arg7 = (int *) 0 ;
    int arg8 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiiOiOi:c_cprect",&obj0,&arg2,&arg3,&arg4,&obj4,&arg6,&obj6,&arg8)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj0,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg1 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg5 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj6,PyArray_INT,0,0);
        arg7 = (int *) arr->data;
    }
    c_cprect(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_cpcldr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    float *arg2 = (float *) 0 ;
    int *arg3 = (int *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:c_cpcldr",&obj0,&obj1,&obj2)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj0,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg1 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg2 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_INT,0,0);
        arg3 = (int *) arr->data;
    }
    c_cpcldr(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_plchhq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    NhlString arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ffsfff:c_plchhq",&arg1,&arg2,&arg3,&arg4,&arg5,&arg6)) goto fail;
    c_plchhq(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_open_wks_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    ResInfo *arg3 = (ResInfo *) 0 ;
    ResInfo *arg4 = (ResInfo *) 0 ;
    nglRes *arg5 = (nglRes *) 0 ;
    int result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    printf("Got to open workstation\n");
    if(!PyArg_ParseTuple(args,(char *)"ssOOO:open_wks_wrap",&arg1,&arg2,&obj2,&obj3,&obj4)) goto fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj2)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj2);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj2, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg3 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj3)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj3);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj3, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg4 = (ResInfo *) &trname;
    }
    {
        arg5 = (void *) &nglRlist;
    }
    result = (int)open_wks_wrap((char const *)arg1,(char const *)arg2,arg3,arg4,arg5);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_labelbar_ndc_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    NhlString *arg3 = (NhlString *) 0 ;
    int arg4 ;
    void *arg5 = (void *) 0 ;
    void *arg6 = (void *) 0 ;
    char *arg7 ;
    char *arg8 ;
    ResInfo *arg9 = (ResInfo *) 0 ;
    nglRes *arg10 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj2 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOiOOssOO:labelbar_ndc_wrap",&arg1,&arg2,&obj2,&arg4,&obj4,&obj5,&arg7,&arg8,&obj8,&obj9)) goto fail;
    {
        if (PyList_Check(obj2)) {
            int size = PyList_Size(obj2);
            int i = 0;
            arg3 = (NhlString *) malloc((size+1)*sizeof(char *));
            if (size == 0) {
                arg3[0] = 0;
            }
            else {
                for (i = 0; i < size; i++) {
                    PyObject *o = PyList_GetItem(obj2,i);
                    if (PyString_Check(o)) {
                        arg3[i] = PyString_AsString(PyList_GetItem(obj2,i));
                    }
                    else {
                        PyErr_SetString(PyExc_TypeError,"List must contain strings");
                        free (arg3);
                        return NULL;
                    }
                }
            }
        } else {
            PyErr_SetString(PyExc_TypeError,"Not a list");
            return NULL;
        }
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        arg5 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj5,PyArray_DOUBLE,0,0);
        arg6 = (void *) arr->data;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj8)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj8);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj8, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg9 = (ResInfo *) &trname;
    }
    {
        arg10 = (void *) &nglRlist;
    }
    result = labelbar_ndc_wrap(arg1,arg2,arg3,arg4,arg5,arg6,(char const *)arg7,(char const *)arg8,arg9,arg10);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_legend_ndc_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    NhlString *arg3 = (NhlString *) 0 ;
    int arg4 ;
    void *arg5 = (void *) 0 ;
    void *arg6 = (void *) 0 ;
    char *arg7 ;
    char *arg8 ;
    ResInfo *arg9 = (ResInfo *) 0 ;
    nglRes *arg10 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj2 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiOiOOssOO:legend_ndc_wrap",&arg1,&arg2,&obj2,&arg4,&obj4,&obj5,&arg7,&arg8,&obj8,&obj9)) goto fail;
    {
        if (PyList_Check(obj2)) {
            int size = PyList_Size(obj2);
            int i = 0;
            arg3 = (NhlString *) malloc((size+1)*sizeof(char *));
            if (size == 0) {
                arg3[0] = 0;
            }
            else {
                for (i = 0; i < size; i++) {
                    PyObject *o = PyList_GetItem(obj2,i);
                    if (PyString_Check(o)) {
                        arg3[i] = PyString_AsString(PyList_GetItem(obj2,i));
                    }
                    else {
                        PyErr_SetString(PyExc_TypeError,"List must contain strings");
                        free (arg3);
                        return NULL;
                    }
                }
            }
        } else {
            PyErr_SetString(PyExc_TypeError,"Not a list");
            return NULL;
        }
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        arg5 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj5,PyArray_DOUBLE,0,0);
        arg6 = (void *) arr->data;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj8)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj8);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj8, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg9 = (ResInfo *) &trname;
    }
    {
        arg10 = (void *) &nglRlist;
    }
    result = legend_ndc_wrap(arg1,arg2,arg3,arg4,arg5,arg6,(char const *)arg7,(char const *)arg8,arg9,arg10);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_contour_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    char *arg3 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    void *arg7 = (void *) 0 ;
    char *arg8 ;
    int arg9 ;
    void *arg10 = (void *) 0 ;
    char *arg11 ;
    int arg12 ;
    void *arg13 = (void *) 0 ;
    ResInfo *arg14 = (ResInfo *) 0 ;
    ResInfo *arg15 = (ResInfo *) 0 ;
    ResInfo *arg16 = (ResInfo *) 0 ;
    nglRes *arg17 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOsiiiOsiOsiOOOOO:contour_wrap",&arg1,&obj1,&arg3,&arg4,&arg5,&arg6,&obj6,&arg8,&arg9,&obj9,&arg11,&arg12,&obj12,&obj13,&obj14,&obj15,&obj16)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj6,(void **) &arg7, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj9,(void **) &arg10, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj12,(void **) &arg13, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj13)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj13);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj13, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg14 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj14)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj14);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj14, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg15 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj15)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj15);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj15, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg16 = (ResInfo *) &trname;
    }
    {
        arg17 = (void *) &nglRlist;
    }
    result = contour_wrap(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,arg9,arg10,(char const *)arg11,arg12,arg13,arg14,arg15,arg16,arg17);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_map_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ResInfo *arg2 = (ResInfo *) 0 ;
    nglRes *arg3 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOO:map_wrap",&arg1,&obj1,&obj2)) goto fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj1)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj1);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj1, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg2 = (ResInfo *) &trname;
    }
    {
        arg3 = (void *) &nglRlist;
    }
    result = map_wrap(arg1,arg2,arg3);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_contour_map_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    char *arg3 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    void *arg7 = (void *) 0 ;
    char *arg8 ;
    int arg9 ;
    void *arg10 = (void *) 0 ;
    char *arg11 ;
    int arg12 ;
    void *arg13 = (void *) 0 ;
    ResInfo *arg14 = (ResInfo *) 0 ;
    ResInfo *arg15 = (ResInfo *) 0 ;
    ResInfo *arg16 = (ResInfo *) 0 ;
    nglRes *arg17 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOsiiiOsiOsiOOOOO:contour_map_wrap",&arg1,&obj1,&arg3,&arg4,&arg5,&arg6,&obj6,&arg8,&arg9,&obj9,&arg11,&arg12,&obj12,&obj13,&obj14,&obj15,&obj16)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj6,(void **) &arg7, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj9,(void **) &arg10, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj12,(void **) &arg13, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj13)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj13);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj13, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg14 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj14)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj14);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj14, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg15 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj15)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj15);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj15, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg16 = (ResInfo *) &trname;
    }
    {
        arg17 = (void *) &nglRlist;
    }
    result = contour_map_wrap(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,arg9,arg10,(char const *)arg11,arg12,arg13,arg14,arg15,arg16,arg17);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_xy_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 ;
    char *arg5 ;
    int arg6 ;
    int *arg7 = (int *) 0 ;
    int arg8 ;
    int *arg9 = (int *) 0 ;
    int arg10 ;
    int arg11 ;
    void *arg12 = (void *) 0 ;
    void *arg13 = (void *) 0 ;
    ResInfo *arg14 = (ResInfo *) 0 ;
    ResInfo *arg15 = (ResInfo *) 0 ;
    ResInfo *arg16 = (ResInfo *) 0 ;
    nglRes *arg17 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOssiOiOiiOOOOOO:xy_wrap",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&obj6,&arg8,&obj8,&arg10,&arg11,&obj11,&obj12,&obj13,&obj14,&obj15,&obj16)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj6,PyArray_INT,0,0);
        arg7 = (int *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj8,PyArray_INT,0,0);
        arg9 = (int *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj11,(void **) &arg12, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj12,(void **) &arg13, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj13)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj13);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj13, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg14 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj14)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj14);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj14, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg15 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj15)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj15);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj15, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg16 = (ResInfo *) &trname;
    }
    {
        arg17 = (void *) &nglRlist;
    }
    result = xy_wrap(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_y_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    char *arg3 ;
    int arg4 ;
    int *arg5 = (int *) 0 ;
    int arg6 ;
    void *arg7 = (void *) 0 ;
    ResInfo *arg8 = (ResInfo *) 0 ;
    ResInfo *arg9 = (ResInfo *) 0 ;
    ResInfo *arg10 = (ResInfo *) 0 ;
    nglRes *arg11 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOsiOiOOOOO:y_wrap",&arg1,&obj1,&arg3,&arg4,&obj4,&arg6,&obj6,&obj7,&obj8,&obj9,&obj10)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_INT,0,0);
        arg5 = (int *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj6,(void **) &arg7, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj7)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj7);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj7, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg8 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj8)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj8);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj8, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg9 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj9)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj9);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj9, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg10 = (ResInfo *) &trname;
    }
    {
        arg11 = (void *) &nglRlist;
    }
    result = y_wrap(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_vector_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 ;
    char *arg5 ;
    int arg6 ;
    int arg7 ;
    int arg8 ;
    void *arg9 = (void *) 0 ;
    char *arg10 ;
    int arg11 ;
    void *arg12 = (void *) 0 ;
    char *arg13 ;
    int arg14 ;
    int arg15 ;
    void *arg16 = (void *) 0 ;
    void *arg17 = (void *) 0 ;
    ResInfo *arg18 = (ResInfo *) 0 ;
    ResInfo *arg19 = (ResInfo *) 0 ;
    ResInfo *arg20 = (ResInfo *) 0 ;
    nglRes *arg21 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    PyObject * obj17 = 0 ;
    PyObject * obj18 = 0 ;
    PyObject * obj19 = 0 ;
    PyObject * obj20 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOssiiiOsiOsiiOOOOOO:vector_wrap",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8,&obj8,&arg10,&arg11,&obj11,&arg13,&arg14,&arg15,&obj15,&obj16,&obj17,&obj18,&obj19,&obj20)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj8,(void **) &arg9, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj11,(void **) &arg12, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj15,(void **) &arg16, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj16,(void **) &arg17, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj17)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj17);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj17, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg18 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj18)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj18);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj18, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg19 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj19)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj19);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj19, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg20 = (ResInfo *) &trname;
    }
    {
        arg21 = (void *) &nglRlist;
    }
    result = vector_wrap(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,arg6,arg7,arg8,arg9,(char const *)arg10,arg11,arg12,(char const *)arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_vector_map_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 ;
    char *arg5 ;
    int arg6 ;
    int arg7 ;
    int arg8 ;
    void *arg9 = (void *) 0 ;
    char *arg10 ;
    int arg11 ;
    void *arg12 = (void *) 0 ;
    char *arg13 ;
    int arg14 ;
    int arg15 ;
    void *arg16 = (void *) 0 ;
    void *arg17 = (void *) 0 ;
    ResInfo *arg18 = (ResInfo *) 0 ;
    ResInfo *arg19 = (ResInfo *) 0 ;
    ResInfo *arg20 = (ResInfo *) 0 ;
    nglRes *arg21 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    PyObject * obj17 = 0 ;
    PyObject * obj18 = 0 ;
    PyObject * obj19 = 0 ;
    PyObject * obj20 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOssiiiOsiOsiiOOOOOO:vector_map_wrap",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8,&obj8,&arg10,&arg11,&obj11,&arg13,&arg14,&arg15,&obj15,&obj16,&obj17,&obj18,&obj19,&obj20)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj8,(void **) &arg9, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj11,(void **) &arg12, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj15,(void **) &arg16, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj16,(void **) &arg17, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj17)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj17);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj17, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg18 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj18)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj18);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj18, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg19 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj19)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj19);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj19, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg20 = (ResInfo *) &trname;
    }
    {
        arg21 = (void *) &nglRlist;
    }
    result = vector_map_wrap(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,arg6,arg7,arg8,arg9,(char const *)arg10,arg11,arg12,(char const *)arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_vector_scalar_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    char *arg5 ;
    char *arg6 ;
    char *arg7 ;
    int arg8 ;
    int arg9 ;
    int arg10 ;
    void *arg11 = (void *) 0 ;
    char *arg12 ;
    int arg13 ;
    void *arg14 = (void *) 0 ;
    char *arg15 ;
    int arg16 ;
    int arg17 ;
    int arg18 ;
    void *arg19 = (void *) 0 ;
    void *arg20 = (void *) 0 ;
    void *arg21 = (void *) 0 ;
    ResInfo *arg22 = (ResInfo *) 0 ;
    ResInfo *arg23 = (ResInfo *) 0 ;
    ResInfo *arg24 = (ResInfo *) 0 ;
    ResInfo *arg25 = (ResInfo *) 0 ;
    nglRes *arg26 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj18 = 0 ;
    PyObject * obj19 = 0 ;
    PyObject * obj20 = 0 ;
    PyObject * obj21 = 0 ;
    PyObject * obj22 = 0 ;
    PyObject * obj23 = 0 ;
    PyObject * obj24 = 0 ;
    PyObject * obj25 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOOsssiiiOsiOsiiiOOOOOOOO:vector_scalar_wrap",&arg1,&obj1,&obj2,&obj3,&arg5,&arg6,&arg7,&arg8,&arg9,&arg10,&obj10,&arg12,&arg13,&obj13,&arg15,&arg16,&arg17,&arg18,&obj18,&obj19,&obj20,&obj21,&obj22,&obj23,&obj24,&obj25)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj10,(void **) &arg11, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj13,(void **) &arg14, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj18,(void **) &arg19, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj19,(void **) &arg20, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj20,(void **) &arg21, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj21)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj21);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj21, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg22 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj22)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj22);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj22, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg23 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj23)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj23);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj23, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg24 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj24)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj24);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj24, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg25 = (ResInfo *) &trname;
    }
    {
        arg26 = (void *) &nglRlist;
    }
    result = vector_scalar_wrap(arg1,arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8,arg9,arg10,arg11,(char const *)arg12,arg13,arg14,(char const *)arg15,arg16,arg17,arg18,arg19,arg20,arg21,arg22,arg23,arg24,arg25,arg26);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_vector_scalar_map_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    char *arg5 ;
    char *arg6 ;
    char *arg7 ;
    int arg8 ;
    int arg9 ;
    int arg10 ;
    void *arg11 = (void *) 0 ;
    char *arg12 ;
    int arg13 ;
    void *arg14 = (void *) 0 ;
    char *arg15 ;
    int arg16 ;
    int arg17 ;
    int arg18 ;
    void *arg19 = (void *) 0 ;
    void *arg20 = (void *) 0 ;
    void *arg21 = (void *) 0 ;
    ResInfo *arg22 = (ResInfo *) 0 ;
    ResInfo *arg23 = (ResInfo *) 0 ;
    ResInfo *arg24 = (ResInfo *) 0 ;
    ResInfo *arg25 = (ResInfo *) 0 ;
    nglRes *arg26 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj18 = 0 ;
    PyObject * obj19 = 0 ;
    PyObject * obj20 = 0 ;
    PyObject * obj21 = 0 ;
    PyObject * obj22 = 0 ;
    PyObject * obj23 = 0 ;
    PyObject * obj24 = 0 ;
    PyObject * obj25 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOOsssiiiOsiOsiiiOOOOOOOO:vector_scalar_map_wrap",&arg1,&obj1,&obj2,&obj3,&arg5,&arg6,&arg7,&arg8,&arg9,&arg10,&obj10,&arg12,&arg13,&obj13,&arg15,&arg16,&arg17,&arg18,&obj18,&obj19,&obj20,&obj21,&obj22,&obj23,&obj24,&obj25)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj10,(void **) &arg11, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj13,(void **) &arg14, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj18,(void **) &arg19, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj19,(void **) &arg20, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj20,(void **) &arg21, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj21)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj21);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj21, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg22 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj22)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj22);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj22, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg23 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj23)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj23);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj23, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg24 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj24)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj24);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj24, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg25 = (ResInfo *) &trname;
    }
    {
        arg26 = (void *) &nglRlist;
    }
    result = vector_scalar_map_wrap(arg1,arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8,arg9,arg10,arg11,(char const *)arg12,arg13,arg14,(char const *)arg15,arg16,arg17,arg18,arg19,arg20,arg21,arg22,arg23,arg24,arg25,arg26);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_streamline_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 ;
    char *arg5 ;
    int arg6 ;
    int arg7 ;
    int arg8 ;
    void *arg9 = (void *) 0 ;
    char *arg10 ;
    int arg11 ;
    void *arg12 = (void *) 0 ;
    char *arg13 ;
    int arg14 ;
    int arg15 ;
    void *arg16 = (void *) 0 ;
    void *arg17 = (void *) 0 ;
    ResInfo *arg18 = (ResInfo *) 0 ;
    ResInfo *arg19 = (ResInfo *) 0 ;
    ResInfo *arg20 = (ResInfo *) 0 ;
    nglRes *arg21 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    PyObject * obj17 = 0 ;
    PyObject * obj18 = 0 ;
    PyObject * obj19 = 0 ;
    PyObject * obj20 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOssiiiOsiOsiiOOOOOO:streamline_wrap",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8,&obj8,&arg10,&arg11,&obj11,&arg13,&arg14,&arg15,&obj15,&obj16,&obj17,&obj18,&obj19,&obj20)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj8,(void **) &arg9, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj11,(void **) &arg12, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj15,(void **) &arg16, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj16,(void **) &arg17, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj17)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj17);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj17, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg18 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj18)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj18);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj18, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg19 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj19)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj19);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj19, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg20 = (ResInfo *) &trname;
    }
    {
        arg21 = (void *) &nglRlist;
    }
    result = streamline_wrap(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,arg6,arg7,arg8,arg9,(char const *)arg10,arg11,arg12,(char const *)arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_streamline_map_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 ;
    char *arg5 ;
    int arg6 ;
    int arg7 ;
    int arg8 ;
    void *arg9 = (void *) 0 ;
    char *arg10 ;
    int arg11 ;
    void *arg12 = (void *) 0 ;
    char *arg13 ;
    int arg14 ;
    int arg15 ;
    void *arg16 = (void *) 0 ;
    void *arg17 = (void *) 0 ;
    ResInfo *arg18 = (ResInfo *) 0 ;
    ResInfo *arg19 = (ResInfo *) 0 ;
    ResInfo *arg20 = (ResInfo *) 0 ;
    nglRes *arg21 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    PyObject * obj17 = 0 ;
    PyObject * obj18 = 0 ;
    PyObject * obj19 = 0 ;
    PyObject * obj20 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOssiiiOsiOsiiOOOOOO:streamline_map_wrap",&arg1,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8,&obj8,&arg10,&arg11,&obj11,&arg13,&arg14,&arg15,&obj15,&obj16,&obj17,&obj18,&obj19,&obj20)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj8,(void **) &arg9, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj11,(void **) &arg12, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj15,(void **) &arg16, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj16,(void **) &arg17, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj17)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj17);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj17, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg18 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj18)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj18);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj18, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg19 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj19)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj19);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj19, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg20 = (ResInfo *) &trname;
    }
    {
        arg21 = (void *) &nglRlist;
    }
    result = streamline_map_wrap(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,arg6,arg7,arg8,arg9,(char const *)arg10,arg11,arg12,(char const *)arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_text_ndc_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    char *arg5 ;
    char *arg6 ;
    ResInfo *arg7 = (ResInfo *) 0 ;
    nglRes *arg8 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOOssOO:text_ndc_wrap",&arg1,&arg2,&obj2,&obj3,&arg5,&arg6,&obj6,&obj7)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj6)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj6);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj6, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg7 = (ResInfo *) &trname;
    }
    {
        arg8 = (void *) &nglRlist;
    }
    result = text_ndc_wrap(arg1,arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,arg7,arg8);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_text_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    nglPlotId *arg2 = (nglPlotId *) 0 ;
    NhlString arg3 ;
    void *arg4 = (void *) 0 ;
    void *arg5 = (void *) 0 ;
    char *arg6 ;
    char *arg7 ;
    ResInfo *arg8 = (ResInfo *) 0 ;
    nglRes *arg9 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOsOOssOO:text_wrap",&arg1,&obj1,&arg3,&obj3,&obj4,&arg6,&arg7,&obj7,&obj8)) goto fail;
    {
        int i;
        nglPlotId inlist;
        
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        int      *ibase,       *icontour,  *ivector,   *istreamline,
        *imap,        *ixy     ,  *ixydspec,  *itext,
        *iprimitive,  *icafield,  *isffield,  *ivffield;
        
        if (PyList_Check(obj1) == 0) {
            printf("PlotIds must be Python lists\n"); 
        }
        
        l_base = PyList_GetItem(obj1,0);
        if (l_base == Py_None) {
            inlist.nbase = 0;
            inlist.base = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_base)) {
                printf("PlotId base element must be None or a Python list\n");
            }
            else {
                inlist.nbase = PyList_Size(l_base);
                ibase = (int *) malloc(inlist.nbase*sizeof(int));
                for (i = 0; i < inlist.nbase; i++) {
                    *(ibase+i) = (int) PyInt_AsLong(PyList_GetItem(l_base,i));
                }
                inlist.base = ibase;
            }
        }
        
        l_contour = PyList_GetItem(obj1,1);
        if (l_contour == Py_None) {
            inlist.ncontour = 0;
            inlist.contour = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_contour)) {
                printf("PlotId contour element must be None or a Python list\n");
            }
            else {
                inlist.ncontour = PyList_Size(l_contour);
                icontour = (int *) malloc(inlist.ncontour*sizeof(int));
                for (i = 0; i < inlist.ncontour; i++) {
                    *(icontour+i) = (int) PyInt_AsLong(PyList_GetItem(l_contour,i));
                }
                inlist.contour = icontour;
            }
        }
        
        l_vector = PyList_GetItem(obj1,2);
        if (l_vector == Py_None) {
            inlist.nvector = 0;
            inlist.vector = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vector)) {
                printf("PlotId vector element must be None or a Python list\n");
            }
            else {
                inlist.nvector = PyList_Size(l_vector);
                ivector = (int *) malloc(inlist.nvector*sizeof(int));
                for (i = 0; i < inlist.nvector; i++) {
                    *(ivector+i) = (int) PyInt_AsLong(PyList_GetItem(l_vector,i));
                }
                inlist.vector = ivector;
            }
        }
        
        l_streamline = PyList_GetItem(obj1,3);
        if (l_streamline == Py_None) {
            inlist.nstreamline = 0;
            inlist.streamline = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_streamline)) {
                printf("PlotId streamline element must be None or a Python list\n");
            }
            else {
                inlist.nstreamline = PyList_Size(l_streamline);
                istreamline = (int *) malloc(inlist.nstreamline*sizeof(int));
                for (i = 0; i < inlist.nstreamline; i++) {
                    *(istreamline+i) = (int) PyInt_AsLong(PyList_GetItem(l_streamline,i));
                }
                inlist.streamline = istreamline;
            }
        }
        
        l_map = PyList_GetItem(obj1,4);
        if (l_map == Py_None) {
            inlist.nmap = 0;
            inlist.map = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_map)) {
                printf("PlotId map element must be None or a Python list\n");
            }
            else {
                inlist.nmap = PyList_Size(l_map);
                imap = (int *) malloc(inlist.nmap*sizeof(int));
                for (i = 0; i < inlist.nmap; i++) {
                    *(imap+i) = (int) PyInt_AsLong(PyList_GetItem(l_map,i));
                }
                inlist.map = imap;
            }
        }
        
        l_xy = PyList_GetItem(obj1,5);
        if (l_xy == Py_None) {
            inlist.nxy = 0;
            inlist.xy = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xy)) {
                printf("PlotId xy element must be None or a Python list\n");
            }
            else {
                inlist.nxy = PyList_Size(l_xy);
                ixy = (int *) malloc(inlist.nxy*sizeof(int));
                for (i = 0; i < inlist.nxy; i++) {
                    *(ixy+i) = (int) PyInt_AsLong(PyList_GetItem(l_xy,i));
                }
                inlist.xy = ixy;
            }
        }
        
        l_xydspec = PyList_GetItem(obj1,6);
        if (l_xydspec == Py_None) {
            inlist.nxydspec = 0;
            inlist.xydspec = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xydspec)) {
                printf("PlotId xydspec element must be None or a Python list\n");
            }
            else {
                inlist.nxydspec = PyList_Size(l_xydspec);
                ixydspec = (int *) malloc(inlist.nxydspec*sizeof(int));
                for (i = 0; i < inlist.nxydspec; i++) {
                    *(ixydspec+i) = (int) PyInt_AsLong(PyList_GetItem(l_xydspec,i));
                }
                inlist.xydspec = ixydspec;
            }
        }
        
        l_text = PyList_GetItem(obj1,7);
        if (l_text == Py_None) {
            inlist.ntext = 0;
            inlist.text = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_text)) {
                printf("PlotId text element must be None or a Python list\n");
            }
            else {
                inlist.ntext = PyList_Size(l_text);
                itext = (int *) malloc(inlist.ntext*sizeof(int));
                for (i = 0; i < inlist.ntext; i++) {
                    *(itext+i) = (int) PyInt_AsLong(PyList_GetItem(l_text,i));
                }
                inlist.text = itext;
            }
        }
        
        l_primitive = PyList_GetItem(obj1,8);
        if (l_primitive == Py_None) {
            inlist.nprimitive = 0;
            inlist.primitive = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_primitive)) {
                printf("PlotId primitive element must be None or a Python list\n");
            }
            else {
                inlist.nprimitive = PyList_Size(l_primitive);
                iprimitive = (int *) malloc(inlist.nprimitive*sizeof(int));
                for (i = 0; i < inlist.nprimitive; i++) {
                    *(iprimitive+i) = (int) PyInt_AsLong(PyList_GetItem(l_primitive,i));
                }
                inlist.primitive = iprimitive;
            }
        }
        
        l_cafield = PyList_GetItem(obj1,9);
        if (l_cafield == Py_None) {
            inlist.ncafield = 0;
            inlist.cafield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_cafield)) {
                printf("PlotId cafield element must be None or a Python list\n");
            }
            else {
                inlist.ncafield = PyList_Size(l_cafield);
                icafield = (int *) malloc(inlist.ncafield*sizeof(int));
                for (i = 0; i < inlist.ncafield; i++) {
                    *(icafield+i) = (int) PyInt_AsLong(PyList_GetItem(l_cafield,i));
                }
                inlist.cafield = icafield;
            }
        }
        
        l_sffield = PyList_GetItem(obj1,10);
        if (l_sffield == Py_None) {
            inlist.nsffield = 0;
            inlist.sffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_sffield)) {
                printf("PlotId sffield element must be None or a Python list\n");
            }
            else {
                inlist.nsffield = PyList_Size(l_sffield);
                isffield = (int *) malloc(inlist.nsffield*sizeof(int));
                for (i = 0; i < inlist.nsffield; i++) {
                    *(isffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_sffield,i));
                }
                inlist.sffield = isffield;
            }
        }
        
        l_vffield = PyList_GetItem(obj1,11);
        if (l_vffield == Py_None) {
            inlist.nvffield = 0;
            inlist.vffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vffield)) {
                printf("PlotId vffield element must be None or a Python list\n");
            }
            else {
                inlist.nvffield = PyList_Size(l_vffield);
                ivffield = (int *) malloc(inlist.nvffield*sizeof(int));
                for (i = 0; i < inlist.nvffield; i++) {
                    *(ivffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_vffield,i));
                }
                inlist.vffield = ivffield;
            }
        }
        
        arg2 = &inlist;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        arg5 = (void *) arr->data;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj7)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj7);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj7, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg8 = (ResInfo *) &trname;
    }
    {
        arg9 = (void *) &nglRlist;
    }
    result = text_wrap(arg1,arg2,arg3,arg4,arg5,(char const *)arg6,(char const *)arg7,arg8,arg9);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_add_text_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    nglPlotId *arg2 = (nglPlotId *) 0 ;
    NhlString arg3 ;
    void *arg4 = (void *) 0 ;
    void *arg5 = (void *) 0 ;
    char *arg6 ;
    char *arg7 ;
    ResInfo *arg8 = (ResInfo *) 0 ;
    ResInfo *arg9 = (ResInfo *) 0 ;
    nglRes *arg10 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOsOOssOOO:add_text_wrap",&arg1,&obj1,&arg3,&obj3,&obj4,&arg6,&arg7,&obj7,&obj8,&obj9)) goto fail;
    {
        int i;
        nglPlotId inlist;
        
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        int      *ibase,       *icontour,  *ivector,   *istreamline,
        *imap,        *ixy     ,  *ixydspec,  *itext,
        *iprimitive,  *icafield,  *isffield,  *ivffield;
        
        if (PyList_Check(obj1) == 0) {
            printf("PlotIds must be Python lists\n"); 
        }
        
        l_base = PyList_GetItem(obj1,0);
        if (l_base == Py_None) {
            inlist.nbase = 0;
            inlist.base = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_base)) {
                printf("PlotId base element must be None or a Python list\n");
            }
            else {
                inlist.nbase = PyList_Size(l_base);
                ibase = (int *) malloc(inlist.nbase*sizeof(int));
                for (i = 0; i < inlist.nbase; i++) {
                    *(ibase+i) = (int) PyInt_AsLong(PyList_GetItem(l_base,i));
                }
                inlist.base = ibase;
            }
        }
        
        l_contour = PyList_GetItem(obj1,1);
        if (l_contour == Py_None) {
            inlist.ncontour = 0;
            inlist.contour = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_contour)) {
                printf("PlotId contour element must be None or a Python list\n");
            }
            else {
                inlist.ncontour = PyList_Size(l_contour);
                icontour = (int *) malloc(inlist.ncontour*sizeof(int));
                for (i = 0; i < inlist.ncontour; i++) {
                    *(icontour+i) = (int) PyInt_AsLong(PyList_GetItem(l_contour,i));
                }
                inlist.contour = icontour;
            }
        }
        
        l_vector = PyList_GetItem(obj1,2);
        if (l_vector == Py_None) {
            inlist.nvector = 0;
            inlist.vector = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vector)) {
                printf("PlotId vector element must be None or a Python list\n");
            }
            else {
                inlist.nvector = PyList_Size(l_vector);
                ivector = (int *) malloc(inlist.nvector*sizeof(int));
                for (i = 0; i < inlist.nvector; i++) {
                    *(ivector+i) = (int) PyInt_AsLong(PyList_GetItem(l_vector,i));
                }
                inlist.vector = ivector;
            }
        }
        
        l_streamline = PyList_GetItem(obj1,3);
        if (l_streamline == Py_None) {
            inlist.nstreamline = 0;
            inlist.streamline = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_streamline)) {
                printf("PlotId streamline element must be None or a Python list\n");
            }
            else {
                inlist.nstreamline = PyList_Size(l_streamline);
                istreamline = (int *) malloc(inlist.nstreamline*sizeof(int));
                for (i = 0; i < inlist.nstreamline; i++) {
                    *(istreamline+i) = (int) PyInt_AsLong(PyList_GetItem(l_streamline,i));
                }
                inlist.streamline = istreamline;
            }
        }
        
        l_map = PyList_GetItem(obj1,4);
        if (l_map == Py_None) {
            inlist.nmap = 0;
            inlist.map = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_map)) {
                printf("PlotId map element must be None or a Python list\n");
            }
            else {
                inlist.nmap = PyList_Size(l_map);
                imap = (int *) malloc(inlist.nmap*sizeof(int));
                for (i = 0; i < inlist.nmap; i++) {
                    *(imap+i) = (int) PyInt_AsLong(PyList_GetItem(l_map,i));
                }
                inlist.map = imap;
            }
        }
        
        l_xy = PyList_GetItem(obj1,5);
        if (l_xy == Py_None) {
            inlist.nxy = 0;
            inlist.xy = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xy)) {
                printf("PlotId xy element must be None or a Python list\n");
            }
            else {
                inlist.nxy = PyList_Size(l_xy);
                ixy = (int *) malloc(inlist.nxy*sizeof(int));
                for (i = 0; i < inlist.nxy; i++) {
                    *(ixy+i) = (int) PyInt_AsLong(PyList_GetItem(l_xy,i));
                }
                inlist.xy = ixy;
            }
        }
        
        l_xydspec = PyList_GetItem(obj1,6);
        if (l_xydspec == Py_None) {
            inlist.nxydspec = 0;
            inlist.xydspec = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xydspec)) {
                printf("PlotId xydspec element must be None or a Python list\n");
            }
            else {
                inlist.nxydspec = PyList_Size(l_xydspec);
                ixydspec = (int *) malloc(inlist.nxydspec*sizeof(int));
                for (i = 0; i < inlist.nxydspec; i++) {
                    *(ixydspec+i) = (int) PyInt_AsLong(PyList_GetItem(l_xydspec,i));
                }
                inlist.xydspec = ixydspec;
            }
        }
        
        l_text = PyList_GetItem(obj1,7);
        if (l_text == Py_None) {
            inlist.ntext = 0;
            inlist.text = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_text)) {
                printf("PlotId text element must be None or a Python list\n");
            }
            else {
                inlist.ntext = PyList_Size(l_text);
                itext = (int *) malloc(inlist.ntext*sizeof(int));
                for (i = 0; i < inlist.ntext; i++) {
                    *(itext+i) = (int) PyInt_AsLong(PyList_GetItem(l_text,i));
                }
                inlist.text = itext;
            }
        }
        
        l_primitive = PyList_GetItem(obj1,8);
        if (l_primitive == Py_None) {
            inlist.nprimitive = 0;
            inlist.primitive = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_primitive)) {
                printf("PlotId primitive element must be None or a Python list\n");
            }
            else {
                inlist.nprimitive = PyList_Size(l_primitive);
                iprimitive = (int *) malloc(inlist.nprimitive*sizeof(int));
                for (i = 0; i < inlist.nprimitive; i++) {
                    *(iprimitive+i) = (int) PyInt_AsLong(PyList_GetItem(l_primitive,i));
                }
                inlist.primitive = iprimitive;
            }
        }
        
        l_cafield = PyList_GetItem(obj1,9);
        if (l_cafield == Py_None) {
            inlist.ncafield = 0;
            inlist.cafield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_cafield)) {
                printf("PlotId cafield element must be None or a Python list\n");
            }
            else {
                inlist.ncafield = PyList_Size(l_cafield);
                icafield = (int *) malloc(inlist.ncafield*sizeof(int));
                for (i = 0; i < inlist.ncafield; i++) {
                    *(icafield+i) = (int) PyInt_AsLong(PyList_GetItem(l_cafield,i));
                }
                inlist.cafield = icafield;
            }
        }
        
        l_sffield = PyList_GetItem(obj1,10);
        if (l_sffield == Py_None) {
            inlist.nsffield = 0;
            inlist.sffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_sffield)) {
                printf("PlotId sffield element must be None or a Python list\n");
            }
            else {
                inlist.nsffield = PyList_Size(l_sffield);
                isffield = (int *) malloc(inlist.nsffield*sizeof(int));
                for (i = 0; i < inlist.nsffield; i++) {
                    *(isffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_sffield,i));
                }
                inlist.sffield = isffield;
            }
        }
        
        l_vffield = PyList_GetItem(obj1,11);
        if (l_vffield == Py_None) {
            inlist.nvffield = 0;
            inlist.vffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vffield)) {
                printf("PlotId vffield element must be None or a Python list\n");
            }
            else {
                inlist.nvffield = PyList_Size(l_vffield);
                ivffield = (int *) malloc(inlist.nvffield*sizeof(int));
                for (i = 0; i < inlist.nvffield; i++) {
                    *(ivffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_vffield,i));
                }
                inlist.vffield = ivffield;
            }
        }
        
        arg2 = &inlist;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        arg5 = (void *) arr->data;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj7)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj7);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj7, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg8 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj8)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj8);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj8, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg9 = (ResInfo *) &trname;
    }
    {
        arg10 = (void *) &nglRlist;
    }
    result = add_text_wrap(arg1,arg2,arg3,arg4,arg5,(char const *)arg6,(char const *)arg7,arg8,arg9,arg10);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_poly_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    nglPlotId *arg2 = (nglPlotId *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    char *arg5 ;
    char *arg6 ;
    int arg7 ;
    int arg8 ;
    int arg9 ;
    void *arg10 = (void *) 0 ;
    void *arg11 = (void *) 0 ;
    int arg12 ;
    ResInfo *arg13 = (ResInfo *) 0 ;
    nglRes *arg14 = (nglRes *) 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOOssiiiOOiOO:poly_wrap",&arg1,&obj1,&obj2,&obj3,&arg5,&arg6,&arg7,&arg8,&arg9,&obj9,&obj10,&arg12,&obj12,&obj13)) goto fail;
    {
        int i;
        nglPlotId inlist;
        
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        int      *ibase,       *icontour,  *ivector,   *istreamline,
        *imap,        *ixy     ,  *ixydspec,  *itext,
        *iprimitive,  *icafield,  *isffield,  *ivffield;
        
        if (PyList_Check(obj1) == 0) {
            printf("PlotIds must be Python lists\n"); 
        }
        
        l_base = PyList_GetItem(obj1,0);
        if (l_base == Py_None) {
            inlist.nbase = 0;
            inlist.base = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_base)) {
                printf("PlotId base element must be None or a Python list\n");
            }
            else {
                inlist.nbase = PyList_Size(l_base);
                ibase = (int *) malloc(inlist.nbase*sizeof(int));
                for (i = 0; i < inlist.nbase; i++) {
                    *(ibase+i) = (int) PyInt_AsLong(PyList_GetItem(l_base,i));
                }
                inlist.base = ibase;
            }
        }
        
        l_contour = PyList_GetItem(obj1,1);
        if (l_contour == Py_None) {
            inlist.ncontour = 0;
            inlist.contour = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_contour)) {
                printf("PlotId contour element must be None or a Python list\n");
            }
            else {
                inlist.ncontour = PyList_Size(l_contour);
                icontour = (int *) malloc(inlist.ncontour*sizeof(int));
                for (i = 0; i < inlist.ncontour; i++) {
                    *(icontour+i) = (int) PyInt_AsLong(PyList_GetItem(l_contour,i));
                }
                inlist.contour = icontour;
            }
        }
        
        l_vector = PyList_GetItem(obj1,2);
        if (l_vector == Py_None) {
            inlist.nvector = 0;
            inlist.vector = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vector)) {
                printf("PlotId vector element must be None or a Python list\n");
            }
            else {
                inlist.nvector = PyList_Size(l_vector);
                ivector = (int *) malloc(inlist.nvector*sizeof(int));
                for (i = 0; i < inlist.nvector; i++) {
                    *(ivector+i) = (int) PyInt_AsLong(PyList_GetItem(l_vector,i));
                }
                inlist.vector = ivector;
            }
        }
        
        l_streamline = PyList_GetItem(obj1,3);
        if (l_streamline == Py_None) {
            inlist.nstreamline = 0;
            inlist.streamline = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_streamline)) {
                printf("PlotId streamline element must be None or a Python list\n");
            }
            else {
                inlist.nstreamline = PyList_Size(l_streamline);
                istreamline = (int *) malloc(inlist.nstreamline*sizeof(int));
                for (i = 0; i < inlist.nstreamline; i++) {
                    *(istreamline+i) = (int) PyInt_AsLong(PyList_GetItem(l_streamline,i));
                }
                inlist.streamline = istreamline;
            }
        }
        
        l_map = PyList_GetItem(obj1,4);
        if (l_map == Py_None) {
            inlist.nmap = 0;
            inlist.map = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_map)) {
                printf("PlotId map element must be None or a Python list\n");
            }
            else {
                inlist.nmap = PyList_Size(l_map);
                imap = (int *) malloc(inlist.nmap*sizeof(int));
                for (i = 0; i < inlist.nmap; i++) {
                    *(imap+i) = (int) PyInt_AsLong(PyList_GetItem(l_map,i));
                }
                inlist.map = imap;
            }
        }
        
        l_xy = PyList_GetItem(obj1,5);
        if (l_xy == Py_None) {
            inlist.nxy = 0;
            inlist.xy = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xy)) {
                printf("PlotId xy element must be None or a Python list\n");
            }
            else {
                inlist.nxy = PyList_Size(l_xy);
                ixy = (int *) malloc(inlist.nxy*sizeof(int));
                for (i = 0; i < inlist.nxy; i++) {
                    *(ixy+i) = (int) PyInt_AsLong(PyList_GetItem(l_xy,i));
                }
                inlist.xy = ixy;
            }
        }
        
        l_xydspec = PyList_GetItem(obj1,6);
        if (l_xydspec == Py_None) {
            inlist.nxydspec = 0;
            inlist.xydspec = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xydspec)) {
                printf("PlotId xydspec element must be None or a Python list\n");
            }
            else {
                inlist.nxydspec = PyList_Size(l_xydspec);
                ixydspec = (int *) malloc(inlist.nxydspec*sizeof(int));
                for (i = 0; i < inlist.nxydspec; i++) {
                    *(ixydspec+i) = (int) PyInt_AsLong(PyList_GetItem(l_xydspec,i));
                }
                inlist.xydspec = ixydspec;
            }
        }
        
        l_text = PyList_GetItem(obj1,7);
        if (l_text == Py_None) {
            inlist.ntext = 0;
            inlist.text = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_text)) {
                printf("PlotId text element must be None or a Python list\n");
            }
            else {
                inlist.ntext = PyList_Size(l_text);
                itext = (int *) malloc(inlist.ntext*sizeof(int));
                for (i = 0; i < inlist.ntext; i++) {
                    *(itext+i) = (int) PyInt_AsLong(PyList_GetItem(l_text,i));
                }
                inlist.text = itext;
            }
        }
        
        l_primitive = PyList_GetItem(obj1,8);
        if (l_primitive == Py_None) {
            inlist.nprimitive = 0;
            inlist.primitive = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_primitive)) {
                printf("PlotId primitive element must be None or a Python list\n");
            }
            else {
                inlist.nprimitive = PyList_Size(l_primitive);
                iprimitive = (int *) malloc(inlist.nprimitive*sizeof(int));
                for (i = 0; i < inlist.nprimitive; i++) {
                    *(iprimitive+i) = (int) PyInt_AsLong(PyList_GetItem(l_primitive,i));
                }
                inlist.primitive = iprimitive;
            }
        }
        
        l_cafield = PyList_GetItem(obj1,9);
        if (l_cafield == Py_None) {
            inlist.ncafield = 0;
            inlist.cafield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_cafield)) {
                printf("PlotId cafield element must be None or a Python list\n");
            }
            else {
                inlist.ncafield = PyList_Size(l_cafield);
                icafield = (int *) malloc(inlist.ncafield*sizeof(int));
                for (i = 0; i < inlist.ncafield; i++) {
                    *(icafield+i) = (int) PyInt_AsLong(PyList_GetItem(l_cafield,i));
                }
                inlist.cafield = icafield;
            }
        }
        
        l_sffield = PyList_GetItem(obj1,10);
        if (l_sffield == Py_None) {
            inlist.nsffield = 0;
            inlist.sffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_sffield)) {
                printf("PlotId sffield element must be None or a Python list\n");
            }
            else {
                inlist.nsffield = PyList_Size(l_sffield);
                isffield = (int *) malloc(inlist.nsffield*sizeof(int));
                for (i = 0; i < inlist.nsffield; i++) {
                    *(isffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_sffield,i));
                }
                inlist.sffield = isffield;
            }
        }
        
        l_vffield = PyList_GetItem(obj1,11);
        if (l_vffield == Py_None) {
            inlist.nvffield = 0;
            inlist.vffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vffield)) {
                printf("PlotId vffield element must be None or a Python list\n");
            }
            else {
                inlist.nvffield = PyList_Size(l_vffield);
                ivffield = (int *) malloc(inlist.nvffield*sizeof(int));
                for (i = 0; i < inlist.nvffield; i++) {
                    *(ivffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_vffield,i));
                }
                inlist.vffield = ivffield;
            }
        }
        
        arg2 = &inlist;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj9,(void **) &arg10, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj10,(void **) &arg11, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj12)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj12);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj12, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg13 = (ResInfo *) &trname;
    }
    {
        arg14 = (void *) &nglRlist;
    }
    poly_wrap(arg1,arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,arg7,arg8,arg9,arg10,arg11,(NhlPolyType )arg12,arg13,arg14);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_add_poly_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    nglPlotId *arg2 = (nglPlotId *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    char *arg5 ;
    char *arg6 ;
    int arg7 ;
    int arg8 ;
    int arg9 ;
    void *arg10 = (void *) 0 ;
    void *arg11 = (void *) 0 ;
    int arg12 ;
    ResInfo *arg13 = (ResInfo *) 0 ;
    nglRes *arg14 = (nglRes *) 0 ;
    nglPlotId result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOOssiiiOOiOO:add_poly_wrap",&arg1,&obj1,&obj2,&obj3,&arg5,&arg6,&arg7,&arg8,&arg9,&obj9,&obj10,&arg12,&obj12,&obj13)) goto fail;
    {
        int i;
        nglPlotId inlist;
        
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        int      *ibase,       *icontour,  *ivector,   *istreamline,
        *imap,        *ixy     ,  *ixydspec,  *itext,
        *iprimitive,  *icafield,  *isffield,  *ivffield;
        
        if (PyList_Check(obj1) == 0) {
            printf("PlotIds must be Python lists\n"); 
        }
        
        l_base = PyList_GetItem(obj1,0);
        if (l_base == Py_None) {
            inlist.nbase = 0;
            inlist.base = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_base)) {
                printf("PlotId base element must be None or a Python list\n");
            }
            else {
                inlist.nbase = PyList_Size(l_base);
                ibase = (int *) malloc(inlist.nbase*sizeof(int));
                for (i = 0; i < inlist.nbase; i++) {
                    *(ibase+i) = (int) PyInt_AsLong(PyList_GetItem(l_base,i));
                }
                inlist.base = ibase;
            }
        }
        
        l_contour = PyList_GetItem(obj1,1);
        if (l_contour == Py_None) {
            inlist.ncontour = 0;
            inlist.contour = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_contour)) {
                printf("PlotId contour element must be None or a Python list\n");
            }
            else {
                inlist.ncontour = PyList_Size(l_contour);
                icontour = (int *) malloc(inlist.ncontour*sizeof(int));
                for (i = 0; i < inlist.ncontour; i++) {
                    *(icontour+i) = (int) PyInt_AsLong(PyList_GetItem(l_contour,i));
                }
                inlist.contour = icontour;
            }
        }
        
        l_vector = PyList_GetItem(obj1,2);
        if (l_vector == Py_None) {
            inlist.nvector = 0;
            inlist.vector = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vector)) {
                printf("PlotId vector element must be None or a Python list\n");
            }
            else {
                inlist.nvector = PyList_Size(l_vector);
                ivector = (int *) malloc(inlist.nvector*sizeof(int));
                for (i = 0; i < inlist.nvector; i++) {
                    *(ivector+i) = (int) PyInt_AsLong(PyList_GetItem(l_vector,i));
                }
                inlist.vector = ivector;
            }
        }
        
        l_streamline = PyList_GetItem(obj1,3);
        if (l_streamline == Py_None) {
            inlist.nstreamline = 0;
            inlist.streamline = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_streamline)) {
                printf("PlotId streamline element must be None or a Python list\n");
            }
            else {
                inlist.nstreamline = PyList_Size(l_streamline);
                istreamline = (int *) malloc(inlist.nstreamline*sizeof(int));
                for (i = 0; i < inlist.nstreamline; i++) {
                    *(istreamline+i) = (int) PyInt_AsLong(PyList_GetItem(l_streamline,i));
                }
                inlist.streamline = istreamline;
            }
        }
        
        l_map = PyList_GetItem(obj1,4);
        if (l_map == Py_None) {
            inlist.nmap = 0;
            inlist.map = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_map)) {
                printf("PlotId map element must be None or a Python list\n");
            }
            else {
                inlist.nmap = PyList_Size(l_map);
                imap = (int *) malloc(inlist.nmap*sizeof(int));
                for (i = 0; i < inlist.nmap; i++) {
                    *(imap+i) = (int) PyInt_AsLong(PyList_GetItem(l_map,i));
                }
                inlist.map = imap;
            }
        }
        
        l_xy = PyList_GetItem(obj1,5);
        if (l_xy == Py_None) {
            inlist.nxy = 0;
            inlist.xy = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xy)) {
                printf("PlotId xy element must be None or a Python list\n");
            }
            else {
                inlist.nxy = PyList_Size(l_xy);
                ixy = (int *) malloc(inlist.nxy*sizeof(int));
                for (i = 0; i < inlist.nxy; i++) {
                    *(ixy+i) = (int) PyInt_AsLong(PyList_GetItem(l_xy,i));
                }
                inlist.xy = ixy;
            }
        }
        
        l_xydspec = PyList_GetItem(obj1,6);
        if (l_xydspec == Py_None) {
            inlist.nxydspec = 0;
            inlist.xydspec = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_xydspec)) {
                printf("PlotId xydspec element must be None or a Python list\n");
            }
            else {
                inlist.nxydspec = PyList_Size(l_xydspec);
                ixydspec = (int *) malloc(inlist.nxydspec*sizeof(int));
                for (i = 0; i < inlist.nxydspec; i++) {
                    *(ixydspec+i) = (int) PyInt_AsLong(PyList_GetItem(l_xydspec,i));
                }
                inlist.xydspec = ixydspec;
            }
        }
        
        l_text = PyList_GetItem(obj1,7);
        if (l_text == Py_None) {
            inlist.ntext = 0;
            inlist.text = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_text)) {
                printf("PlotId text element must be None or a Python list\n");
            }
            else {
                inlist.ntext = PyList_Size(l_text);
                itext = (int *) malloc(inlist.ntext*sizeof(int));
                for (i = 0; i < inlist.ntext; i++) {
                    *(itext+i) = (int) PyInt_AsLong(PyList_GetItem(l_text,i));
                }
                inlist.text = itext;
            }
        }
        
        l_primitive = PyList_GetItem(obj1,8);
        if (l_primitive == Py_None) {
            inlist.nprimitive = 0;
            inlist.primitive = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_primitive)) {
                printf("PlotId primitive element must be None or a Python list\n");
            }
            else {
                inlist.nprimitive = PyList_Size(l_primitive);
                iprimitive = (int *) malloc(inlist.nprimitive*sizeof(int));
                for (i = 0; i < inlist.nprimitive; i++) {
                    *(iprimitive+i) = (int) PyInt_AsLong(PyList_GetItem(l_primitive,i));
                }
                inlist.primitive = iprimitive;
            }
        }
        
        l_cafield = PyList_GetItem(obj1,9);
        if (l_cafield == Py_None) {
            inlist.ncafield = 0;
            inlist.cafield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_cafield)) {
                printf("PlotId cafield element must be None or a Python list\n");
            }
            else {
                inlist.ncafield = PyList_Size(l_cafield);
                icafield = (int *) malloc(inlist.ncafield*sizeof(int));
                for (i = 0; i < inlist.ncafield; i++) {
                    *(icafield+i) = (int) PyInt_AsLong(PyList_GetItem(l_cafield,i));
                }
                inlist.cafield = icafield;
            }
        }
        
        l_sffield = PyList_GetItem(obj1,10);
        if (l_sffield == Py_None) {
            inlist.nsffield = 0;
            inlist.sffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_sffield)) {
                printf("PlotId sffield element must be None or a Python list\n");
            }
            else {
                inlist.nsffield = PyList_Size(l_sffield);
                isffield = (int *) malloc(inlist.nsffield*sizeof(int));
                for (i = 0; i < inlist.nsffield; i++) {
                    *(isffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_sffield,i));
                }
                inlist.sffield = isffield;
            }
        }
        
        l_vffield = PyList_GetItem(obj1,11);
        if (l_vffield == Py_None) {
            inlist.nvffield = 0;
            inlist.vffield = (int *) NULL;
        }
        else {
            if (!PyList_Check(l_vffield)) {
                printf("PlotId vffield element must be None or a Python list\n");
            }
            else {
                inlist.nvffield = PyList_Size(l_vffield);
                ivffield = (int *) malloc(inlist.nvffield*sizeof(int));
                for (i = 0; i < inlist.nvffield; i++) {
                    *(ivffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_vffield,i));
                }
                inlist.vffield = ivffield;
            }
        }
        
        arg2 = &inlist;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (void *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        arg4 = (void *) arr->data;
    }
    if ((SWIG_ConvertPtr(obj9,(void **) &arg10, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj10,(void **) &arg11, 0, SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj12)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj12);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj12, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg13 = (ResInfo *) &trname;
    }
    {
        arg14 = (void *) &nglRlist;
    }
    result = add_poly_wrap(arg1,arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,arg7,arg8,arg9,arg10,arg11,(NhlPolyType )arg12,arg13,arg14);
    
    {
        PyObject *return_list;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        nglPlotId pid;
        int i;
        
        pid = result;
        
        return_list = PyList_New(12);
        
        if (pid.nbase == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,0,Py_None);
        }
        else {
            l_base = PyList_New(pid.nbase);
            for (i = 0; i < pid.nbase; i++) {
                PyList_SetItem(l_base,i,PyInt_FromLong((long) *(pid.base+i)));
            }
            PyList_SetItem(return_list,0,l_base);
        }
        
        if (pid.ncontour == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,1,Py_None);
        }
        else {
            l_contour = PyList_New(pid.ncontour);
            for (i = 0; i < pid.ncontour; i++) {
                PyList_SetItem(l_contour,i,PyInt_FromLong((long) *(pid.contour+i)));
            }
            PyList_SetItem(return_list,1,l_contour);
        }
        
        if (pid.nvector == 0) {
            PyList_SetItem(return_list,2,Py_None);
        }
        else {
            l_vector = PyList_New(pid.nvector);
            for (i = 0; i < pid.nvector; i++) {
                PyList_SetItem(l_vector,i,PyInt_FromLong((long) *(pid.vector+i)));
            }
            PyList_SetItem(return_list,2,l_vector);
        }
        
        if (pid.nstreamline == 0) {
            PyList_SetItem(return_list,3,Py_None);
        }
        else {
            l_streamline = PyList_New(pid.nstreamline);
            for (i = 0; i < pid.nstreamline; i++) {
                PyList_SetItem(l_streamline,i,PyInt_FromLong((long) *(pid.streamline+i)));
            }
            PyList_SetItem(return_list,3,l_streamline);
        }
        
        if (pid.nmap == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,4,Py_None);
        }
        else {
            l_map = PyList_New(pid.nmap);
            for (i = 0; i < pid.nmap; i++) {
                PyList_SetItem(l_map,i,PyInt_FromLong((long) *(pid.map+i)));
            }
            PyList_SetItem(return_list,4,l_map);
        }
        
        if (pid.nxy == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,5,Py_None);
        }
        else {
            l_xy = PyList_New(pid.nxy);
            for (i = 0; i < pid.nxy; i++) {
                PyList_SetItem(l_xy,i,PyInt_FromLong((long) *(pid.xy+i)));
            }
            PyList_SetItem(return_list,5,l_xy);
        }
        
        if (pid.nxydspec == 0) {
            PyList_SetItem(return_list,6,Py_None);
        }
        else {
            l_xydspec = PyList_New(pid.nxydspec);
            for (i = 0; i < pid.nxydspec; i++) {
                PyList_SetItem(l_xydspec,i,PyInt_FromLong((long) *(pid.xydspec+i)));
            }
            PyList_SetItem(return_list,6,l_xydspec);
        }
        
        if (pid.ntext == 0) {
            PyList_SetItem(return_list,7,Py_None);
        }
        else {
            l_text = PyList_New(pid.ntext);
            for (i = 0; i < pid.ntext; i++) {
                PyList_SetItem(l_text,i,PyInt_FromLong((long) *(pid.text+i)));
            }
            PyList_SetItem(return_list,7,l_text);
        }
        
        if (pid.nprimitive == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,8,Py_None);
        }
        else {
            l_primitive = PyList_New(pid.nprimitive);
            for (i = 0; i < pid.nprimitive; i++) {
                PyList_SetItem(l_primitive,i,PyInt_FromLong((long) *(pid.primitive+i)));
            }
            PyList_SetItem(return_list,8,l_primitive);
        }
        
        if (pid.ncafield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,9,Py_None);
        }
        else {
            l_cafield = PyList_New(pid.ncafield);
            for (i = 0; i < pid.ncafield; i++) {
                PyList_SetItem(l_cafield,i,PyInt_FromLong((long) *(pid.cafield+i)));
            }
            PyList_SetItem(return_list,9,l_cafield);
        }
        
        if (pid.nsffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,10,Py_None);
        }
        else {
            l_sffield = PyList_New(pid.nsffield);
            for (i = 0; i < pid.nsffield; i++) {
                PyList_SetItem(l_sffield,i,PyInt_FromLong((long) *(pid.sffield+i)));
            }
            PyList_SetItem(return_list,10,l_sffield);
        }
        
        if (pid.nvffield == 0) {
            Py_INCREF(Py_None); 
            PyList_SetItem(return_list,11,Py_None);
        }
        else {
            l_vffield = PyList_New(pid.nvffield);
            for (i = 0; i < pid.nvffield; i++) {
                PyList_SetItem(l_vffield,i,PyInt_FromLong((long) *(pid.vffield+i)));
            }
            PyList_SetItem(return_list,11,l_vffield);
        }
        
        Py_INCREF(return_list); 
        resultobj = return_list;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_panel_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    nglPlotId *arg2 = (nglPlotId *) 0 ;
    int arg3 ;
    int *arg4 = (int *) 0 ;
    int arg5 ;
    ResInfo *arg6 = (ResInfo *) 0 ;
    ResInfo *arg7 = (ResInfo *) 0 ;
    nglRes *arg8 = (nglRes *) 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOiOiOOO:panel_wrap",&arg1,&obj1,&arg3,&obj3,&arg5,&obj5,&obj6,&obj7)) goto fail;
    {
        nglPlotId *inlist;
        PyObject *ptmp;
        PyObject *l_base,      *l_contour, *l_vector,  *l_streamline,
        *l_map,       *l_xy     , *l_xydspec, *l_text,
        *l_primitive, *l_cafield, *l_sffield, *l_vffield;
        int      *ibase,       *icontour,  *ivector,   *istreamline,
        *imap,        *ixy     ,  *ixydspec,  *itext,
        *iprimitive,  *icafield,  *isffield,  *ivffield;
        int      i,j;
        
        if (!PyList_Check(obj1)) {
            printf("PlotIds must be a Python list\n");
            Py_INCREF(Py_None);
            return Py_None;
        }
        
        inlist = (nglPlotId *) malloc(PyList_Size(obj1)*sizeof(nglPlotId));
        
        for (j = 0; j < PyList_Size(obj1); j++) {
            ptmp = PyList_GetItem(obj1,j);  /* ptmp is an Ngl Python plot id */
            
            l_base = PyList_GetItem(ptmp,0);
            if (l_base == Py_None) {
                inlist[j].nbase = 0;
                inlist[j].base = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_base)) {
                    printf("PlotId base element must be None or a Python list\n");
                }
                else {
                    inlist[j].nbase = PyList_Size(l_base);
                    ibase = (int *) malloc(inlist[j].nbase*sizeof(int));
                    for (i = 0; i < inlist[j].nbase; i++) {
                        *(ibase+i) = (int) PyInt_AsLong(PyList_GetItem(l_base,i));
                    }
                    inlist[j].base = ibase;
                }
            }
            
            l_contour = PyList_GetItem(ptmp,1);
            if (l_contour == Py_None) {
                inlist[j].ncontour = 0;
                inlist[j].contour = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_contour)) {
                    printf("PlotId contour element must be None or a Python list\n");
                }
                else {
                    inlist[j].ncontour = PyList_Size(l_contour);
                    icontour = (int *) malloc(inlist[j].ncontour*sizeof(int));
                    for (i = 0; i < inlist[j].ncontour; i++) {
                        *(icontour+i) = (int) PyInt_AsLong(PyList_GetItem(l_contour,i));
                    }
                    inlist[j].contour = icontour;
                }
            }
            
            l_vector = PyList_GetItem(ptmp,2);
            if (l_vector == Py_None) {
                inlist[j].nvector = 0;
                inlist[j].vector = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_vector)) {
                    printf("PlotId vector element must be None or a Python list\n");
                }
                else {
                    inlist[j].nvector = PyList_Size(l_vector);
                    ivector = (int *) malloc(inlist[j].nvector*sizeof(int));
                    for (i = 0; i < inlist[j].nvector; i++) {
                        *(ivector+i) = (int) PyInt_AsLong(PyList_GetItem(l_vector,i));
                    }
                    inlist[j].vector = ivector;
                }
            }
            
            l_streamline = PyList_GetItem(ptmp,3);
            if (l_streamline == Py_None) {
                inlist[j].nstreamline = 0;
                inlist[j].streamline = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_streamline)) {
                    printf("PlotId streamline element must be None or a Python list\n");
                }
                else {
                    inlist[j].nstreamline = PyList_Size(l_streamline);
                    istreamline = (int *) malloc(inlist[j].nstreamline*sizeof(int));
                    for (i = 0; i < inlist[j].nstreamline; i++) {
                        *(istreamline+i) = (int) PyInt_AsLong(PyList_GetItem(l_streamline,i));
                    }
                    inlist[j].streamline = istreamline;
                }
            }
            
            l_map = PyList_GetItem(ptmp,4);
            if (l_map == Py_None) {
                inlist[j].nmap = 0;
                inlist[j].map = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_map)) {
                    printf("PlotId map element must be None or a Python list\n");
                }
                else {
                    inlist[j].nmap = PyList_Size(l_map);
                    imap = (int *) malloc(inlist[j].nmap*sizeof(int));
                    for (i = 0; i < inlist[j].nmap; i++) {
                        *(imap+i) = (int) PyInt_AsLong(PyList_GetItem(l_map,i));
                    }
                    inlist[j].map = imap;
                }
            }
            
            l_xy = PyList_GetItem(ptmp,5);
            if (l_xy == Py_None) {
                inlist[j].nxy = 0;
                inlist[j].xy = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_xy)) {
                    printf("PlotId xy element must be None or a Python list\n");
                }
                else {
                    inlist[j].nxy = PyList_Size(l_xy);
                    ixy = (int *) malloc(inlist[j].nxy*sizeof(int));
                    for (i = 0; i < inlist[j].nxy; i++) {
                        *(ixy+i) = (int) PyInt_AsLong(PyList_GetItem(l_xy,i));
                    }
                    inlist[j].xy = ixy;
                }
            }
            
            l_xydspec = PyList_GetItem(ptmp,6);
            if (l_xydspec == Py_None) {
                inlist[j].nxydspec = 0;
                inlist[j].xydspec = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_xydspec)) {
                    printf("PlotId xydspec element must be None or a Python list\n");
                }
                else {
                    inlist[j].nxydspec = PyList_Size(l_xydspec);
                    ixydspec = (int *) malloc(inlist[j].nxydspec*sizeof(int));
                    for (i = 0; i < inlist[j].nxydspec; i++) {
                        *(ixydspec+i) = (int) PyInt_AsLong(PyList_GetItem(l_xydspec,i));
                    }
                    inlist[j].xydspec = ixydspec;
                }
            }
            
            l_text = PyList_GetItem(ptmp,7);
            if (l_text == Py_None) {
                inlist[j].ntext = 0;
                inlist[j].text = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_text)) {
                    printf("PlotId text element must be None or a Python list\n");
                }
                else {
                    inlist[j].ntext = PyList_Size(l_text);
                    itext = (int *) malloc(inlist[j].ntext*sizeof(int));
                    for (i = 0; i < inlist[j].ntext; i++) {
                        *(itext+i) = (int) PyInt_AsLong(PyList_GetItem(l_text,i));
                    }
                    inlist[j].text = itext;
                }
            }
            
            l_primitive = PyList_GetItem(ptmp,8);
            if (l_primitive == Py_None) {
                inlist[j].nprimitive = 0;
                inlist[j].primitive = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_primitive)) {
                    printf("PlotId primitive element must be None or a Python list\n");
                }
                else {
                    inlist[j].nprimitive = PyList_Size(l_primitive);
                    iprimitive = (int *) malloc(inlist[j].nprimitive*sizeof(int));
                    for (i = 0; i < inlist[j].nprimitive; i++) {
                        *(iprimitive+i) = (int) PyInt_AsLong(PyList_GetItem(l_primitive,i));
                    }
                    inlist[j].primitive = iprimitive;
                }
            }
            
            l_cafield = PyList_GetItem(ptmp,9);
            if (l_cafield == Py_None) {
                inlist[j].ncafield = 0;
                inlist[j].cafield = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_cafield)) {
                    printf("PlotId cafield element must be None or a Python list\n");
                }
                else {
                    inlist[j].ncafield = PyList_Size(l_cafield);
                    icafield = (int *) malloc(inlist[j].ncafield*sizeof(int));
                    for (i = 0; i < inlist[j].ncafield; i++) {
                        *(icafield+i) = (int) PyInt_AsLong(PyList_GetItem(l_cafield,i));
                    }
                    inlist[j].cafield = icafield;
                }
            }
            
            l_sffield = PyList_GetItem(ptmp,10);
            if (l_sffield == Py_None) {
                inlist[j].nsffield = 0;
                inlist[j].sffield = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_sffield)) {
                    printf("PlotId sffield element must be None or a Python list\n");
                }
                else {
                    inlist[j].nsffield = PyList_Size(l_sffield);
                    isffield = (int *) malloc(inlist[j].nsffield*sizeof(int));
                    for (i = 0; i < inlist[j].nsffield; i++) {
                        *(isffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_sffield,i));
                    }
                    inlist[j].sffield = isffield;
                }
            }
            
            l_vffield = PyList_GetItem(ptmp,11);
            if (l_vffield == Py_None) {
                inlist[j].nvffield = 0;
                inlist[j].vffield = (int *) NULL;
            }
            else {
                if (!PyList_Check(l_vffield)) {
                    printf("PlotId vffield element must be None or a Python list\n");
                }
                else {
                    inlist[j].nvffield = PyList_Size(l_vffield);
                    ivffield = (int *) malloc(inlist[j].nvffield*sizeof(int));
                    for (i = 0; i < inlist[j].nvffield; i++) {
                        *(ivffield+i) = (int) PyInt_AsLong(PyList_GetItem(l_vffield,i));
                    }
                    inlist[j].vffield = ivffield;
                }
            }
        }
        
        arg2 = inlist;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_INT,0,0);
        arg4 = (int *) arr->data;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj5)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj5);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj5, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg6 = (ResInfo *) &trname;
    }
    {
        int i,pos=0,list_type,list_len,count;
        PyObject *key,*value;
        PyArrayObject *arr;
        char **strings;
        double *dvals;
        int *ivals,array_type,rlist,ndims,*len_dims;
        static ResInfo trname;
        char **trnames;
        
        /*
         *  Clear the resource list.
         */
        rlist = NhlRLCreate(NhlSETRL);
        NhlRLClear(rlist);
        
        /*
         *  Check on the type of the argument - it must be a dictionary.
         */
        if (PyDict_Check(obj6)) {
            count = 0;
            trname.nstrings = PyDict_Size(obj6);
            trnames = (char **) malloc(trname.nstrings*sizeof(char *));
            pos = 0;
            /*
             *  Loop over the keyword/value pairs in the dictionary.
             *  The values must be one of: tuple, int, float, long,
             *  list, string, or array.
             */
            while (PyDict_Next(obj6, &pos, &key, &value)) {
                trnames[count] = PyString_AsString(key);
                count++;
                
                /*
                 *  value is a tuple.
                 */
                if (PyTuple_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a tuple value.
                     */
                    if (PyList_Check(PyTuple_GetItem(value,0)) ||
                    PyTuple_Check(PyTuple_GetItem(value,0))) {
                        printf("Tuple vlaues are not allowed to have list or tuple items.\n");
                        return NULL;
                    }
                    list_len = PyTuple_Size(value);
                    /*
                     *  Determine if the tuple is a tuple of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyTuple_GetItem(value,0))) {
                        /*
                         *  Check that all items in the tuple are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyTuple_GetItem(value,i))) {
                                printf("All items in the tuple value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the tuple value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyTuple_GetItem(value,i))) &&
                            (!PyInt_Check(PyTuple_GetItem(value,i))) ) {
                                printf("All items in the tuple value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        /*
                         *  Check to see if the tuple has all ints and, if not, type it as
                         *  a tuple of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyTuple_GetItem(value,i))) {
                                list_type = 1;
                                break;
                            }
                        }
                    }
                    
                    /*
                     *  Make the appropriate NhlRLSet calls based on the type of
                     *  tuple elements.
                     */
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyTuple_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is a list.
                 */
                else if (PyList_Check(value)) {
                    /*
                     *  Lists and tuples are not allowed as items in a list value.
                     */
                    if (PyList_Check(PyList_GetItem(value,0)) ||
                    PyList_Check(PyList_GetItem(value,0))) {
                        printf("Use Numeric arrays for multiple dimension arrays.\n");
                        return NULL;
                    }
                    list_len = PyList_Size(value);
                    /*
                     *  Determine if the list is a list of strings, ints, or floats.
                     *  
                     *    list_type = 2 (int)
                     *              = 0 (string)
                     *              = 1 (float)
                     */
                    list_type = 2;
                    if (PyString_Check(PyList_GetItem(value,0))) {
                        /*
                         *  Check that all items in the list are strings.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (!PyString_Check(PyList_GetItem(value,i))) {
                                printf("All items in the list value for resource %s must be strings\n",PyString_AsString(key));
                                return NULL;
                                break;
                            }
                        }
                        list_type = 0;
                    }
                    else {
                        /*
                         *  If the items in the list value are not strings, then
                         *  they must all be ints or floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if ( (!PyFloat_Check(PyList_GetItem(value,i))) &&
                            (!PyInt_Check(PyList_GetItem(value,i))) ) {
                                printf("All items in the list value for resource %s must be ints or floats.\n",PyString_AsString(key));
                                return NULL;
                            }
                        }
                        /*
                         *  Check to see if the list has all ints and, if not, type it as
                         *  a list of floats.
                         */
                        for (i = 0; i < list_len ; i++) {
                            if (PyFloat_Check(PyList_GetItem(value,i))) {
                                list_type = 1;
                            }
                        }
                    }
                    switch (list_type) {
                        case 0:
                        strings = (char **) malloc(list_len*sizeof(char *));
                        for (i = 0; i < list_len ; i++) {
                            strings[i] = PyString_AsString(PyList_GetItem(value,i));
                        }
                        NhlRLSetStringArray(rlist,PyString_AsString(key),strings,list_len);
                        break;
                        case 1:
                        dvals = (double *) malloc(list_len*sizeof(double));
                        for (i = 0; i < list_len ; i++) {
                            dvals[i] = PyFloat_AsDouble(PyList_GetItem(value,i));
                        }
                        NhlRLSetDoubleArray(rlist,PyString_AsString(key),dvals,list_len);
                        break;
                        case 2:
                        ivals = (int *) malloc(list_len*sizeof(int));
                        for (i = 0; i < list_len ; i++) {
                            ivals[i] = (int) PyInt_AsLong(PyList_GetItem(value,i));
                        }
                        NhlRLSetIntegerArray(rlist,PyString_AsString(key),ivals,list_len);
                        break;
                    }
                }
                /*
                 *  value is an int.
                 */
                else if (PyInt_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a float.
                 */
                else if (PyFloat_Check(value)) {
                    NhlRLSetDouble(rlist,PyString_AsString(key),PyFloat_AsDouble(value));
                }
                /*
                 *  value is a long.
                 */
                else if (PyLong_Check(value)) {
                    NhlRLSetInteger(rlist,PyString_AsString(key),(int) PyInt_AsLong(value));
                }
                /*
                 *  value is a string
                 */
                else if (PyString_Check(value)) {
                    NhlRLSetString(rlist,PyString_AsString(key),PyString_AsString(value));
                }
                /*
                 *  value is an array.
                 */
                else if (PyArray_Check(value)) {
                    array_type = (int) ((PyArrayObject *)value)->descr->type_num;
                    /*
                     *  Process the legal array types.
                     */
                    if (array_type == PyArray_LONG || array_type == PyArray_INT) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_LONG,0,0);
                        ivals = (int *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        
                        NhlRLSetMDIntegerArray(rlist,PyString_AsString(key),ivals,ndims,len_dims);
                    }
                    else if (array_type == PyArray_FLOAT || array_type == PyArray_DOUBLE) {
                        arr = (PyArrayObject *) PyArray_ContiguousFromObject \
                        ((PyObject *) value,PyArray_DOUBLE,0,0);
                        dvals = (double *)arr->data;
                        ndims = arr->nd;
                        len_dims = arr->dimensions;
                        NhlRLSetMDDoubleArray(rlist,PyString_AsString(key),dvals,ndims,len_dims);
                    }
                    else {
                        printf(
                        "Numeric arrays must be of type int, int32, float, float0, float32, or float64.\n");
                        return NULL;
                    }
                }
                else {
                    printf("  value for keyword %s is invalid.\n",PyString_AsString(key));
                    return NULL;
                }
            }
            trname.strings = trnames;
        }
        else {
            printf("Resource lists must be dictionaries\n");
        }
        trname.id = rlist;
        arg7 = (ResInfo *) &trname;
    }
    {
        arg8 = (void *) &nglRlist;
    }
    panel_wrap(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_mapgci(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    int arg5 ;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ffffi:mapgci",&arg1,&arg2,&arg3,&arg4,&arg5)) goto fail;
    result = (PyObject *)mapgci(arg1,arg2,arg3,arg4,arg5);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dcapethermo(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    double arg4 ;
    int arg5 ;
    double arg6 ;
    PyObject *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOidid:dcapethermo",&obj0,&obj1,&arg3,&arg4,&arg5,&arg6)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj0,PyArray_DOUBLE,0,0);
        arg1 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (double *) arr->data;
    }
    result = (PyObject *)dcapethermo(arg1,arg2,arg3,arg4,arg5,arg6);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_draw_colormap_wrap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    
    if(!PyArg_ParseTuple(args,(char *)"i:draw_colormap_wrap",&arg1)) goto fail;
    draw_colormap_wrap(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_natgridc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *arg2 = (float *) 0 ;
    float *arg3 = (float *) 0 ;
    float *arg4 = (float *) 0 ;
    int arg5 ;
    int arg6 ;
    float *arg7 = (float *) 0 ;
    float *arg8 = (float *) 0 ;
    int *arg9 = (int *) 0 ;
    int arg10 ;
    int arg11 ;
    float **arg12 ;
    int temp9 ;
    float *tempx12 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    arg9 = &temp9;
    {
        arg12 = &tempx12;
    }
    if(!PyArg_ParseTuple(args,(char *)"iOOOiiOOii:natgridc",&arg1,&obj1,&obj2,&obj3,&arg5,&arg6,&obj6,&obj7,&arg10,&arg11)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg2 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj3,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg4 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj6,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg7 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj7,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg8 = (float *) d2f(tdims, (double *) arr->data);
    }
    natgridc(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyInt_FromLong((long) (*arg9));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        int dims[2];
        PyObject *o;
        dims[0] = arg10;
        dims[1] = arg11;
        o = (PyObject *)PyArray_FromDimsAndData(2,dims,PyArray_FLOAT,
        (char *) arg12[0]);
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ftcurvc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *arg2 = (float *) 0 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    float *arg5 = (float *) 0 ;
    PyObject *result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOiO:ftcurvc",&arg1,&obj1,&obj2,&arg4,&obj4)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg2 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg5 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (PyObject *)ftcurvc(arg1,arg2,arg3,arg4,arg5);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ftcurvpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float *arg2 = (float *) 0 ;
    float *arg3 = (float *) 0 ;
    float arg4 ;
    int arg5 ;
    float *arg6 = (float *) 0 ;
    PyObject *result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOOfiO:ftcurvpc",&arg1,&obj1,&obj2,&arg4,&arg5,&obj5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg2 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg3 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj5,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg6 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (PyObject *)ftcurvpc(arg1,arg2,arg3,arg4,arg5,arg6);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ftcurvpic(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    int arg4 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    PyObject *result;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"fffiOO:ftcurvpic",&arg1,&arg2,&arg3,&arg4,&obj4,&obj5)) goto fail;
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg5 = (float *) d2f(tdims, (double *) arr->data);
    }
    {
        int i,ndims,tdims=1;
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj5,PyArray_DOUBLE,0,0);
        ndims = arr->nd;
        for (i = 0; i < ndims; i++) {
            tdims *= arr->dimensions[i];
        }
        arg6 = (float *) d2f(tdims, (double *) arr->data);
    }
    result = (PyObject *)ftcurvpic(arg1,arg2,arg3,arg4,arg5,arg6);
    
    resultobj = result;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_rgbhls(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    float temp4 ;
    float temp5 ;
    float temp6 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"fff:c_rgbhls",&arg1,&arg2,&arg3)) goto fail;
    c_rgbhls(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_hlsrgb(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    float temp4 ;
    float temp5 ;
    float temp6 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"fff:c_hlsrgb",&arg1,&arg2,&arg3)) goto fail;
    c_hlsrgb(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_rgbhsv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    float temp4 ;
    float temp5 ;
    float temp6 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"fff:c_rgbhsv",&arg1,&arg2,&arg3)) goto fail;
    c_rgbhsv(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_hsvrgb(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    float temp4 ;
    float temp5 ;
    float temp6 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"fff:c_hsvrgb",&arg1,&arg2,&arg3)) goto fail;
    c_hsvrgb(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_rgbyiq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    float temp4 ;
    float temp5 ;
    float temp6 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"fff:c_rgbyiq",&arg1,&arg2,&arg3)) goto fail;
    c_rgbyiq(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_yiqrgb(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float *arg4 = (float *) 0 ;
    float *arg5 = (float *) 0 ;
    float *arg6 = (float *) 0 ;
    float temp4 ;
    float temp5 ;
    float temp6 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"fff:c_yiqrgb",&arg1,&arg2,&arg3)) goto fail;
    c_yiqrgb(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmbarbp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iffff:c_wmbarbp",&arg1,&arg2,&arg3,&arg4,&arg5)) goto fail;
    c_wmbarbp(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmsetip(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    int arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"si:c_wmsetip",&arg1,&arg2)) goto fail;
    c_wmsetip(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmsetrp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    float arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sf:c_wmsetrp",&arg1,&arg2)) goto fail;
    c_wmsetrp(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmsetcp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    NhlString arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ss:c_wmsetcp",&arg1,&arg2)) goto fail;
    c_wmsetcp(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmgetip(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:c_wmgetip",&arg1)) goto fail;
    result = (int)c_wmgetip(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmgetrp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    float result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:c_wmgetrp",&arg1)) goto fail;
    result = (float)c_wmgetrp(arg1);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_wmgetcp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    NhlString result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:c_wmgetcp",&arg1)) goto fail;
    result = (NhlString)c_wmgetcp(arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_nnseti(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    int arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"si:c_nnseti",&arg1,&arg2)) goto fail;
    c_nnseti(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_nnsetrd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    double arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sd:c_nnsetrd",&arg1,&arg2)) goto fail;
    c_nnsetrd(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_nnsetc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    NhlString arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ss:c_nnsetc",&arg1,&arg2)) goto fail;
    c_nnsetc(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_nngeti(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    int *arg2 = (int *) 0 ;
    int temp2 ;
    
    arg2 = &temp2;
    if(!PyArg_ParseTuple(args,(char *)"s:c_nngeti",&arg1)) goto fail;
    c_nngeti(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyInt_FromLong((long) (*arg2));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_nngetrd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    double *arg2 = (double *) 0 ;
    double temp2 ;
    
    arg2 = &temp2;
    if(!PyArg_ParseTuple(args,(char *)"s:c_nngetrd",&arg1)) goto fail;
    c_nngetrd(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg2));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_nngetcp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NhlString arg1 ;
    NhlString result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:c_nngetcp",&arg1)) goto fail;
    result = (NhlString)c_nngetcp(arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dgcdist(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    int arg5 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"ddddi:c_dgcdist",&arg1,&arg2,&arg3,&arg4,&arg5)) goto fail;
    result = (double)c_dgcdist(arg1,arg2,arg3,arg4,arg5);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dcapethermo(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    double arg4 ;
    int arg5 ;
    double **arg6 = (double **) 0 ;
    double arg7 ;
    int *arg8 = (int *) 0 ;
    int *arg9 = (int *) 0 ;
    int *arg10 = (int *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOidiOdOOO:c_dcapethermo",&obj0,&obj1,&arg3,&arg4,&arg5,&obj5,&arg7,&obj7,&obj8,&obj9)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj5,(void **) &arg6, SWIGTYPE_p_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj7,(void **) &arg8, SWIGTYPE_p_int,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj8,(void **) &arg9, SWIGTYPE_p_int,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj9,(void **) &arg10, SWIGTYPE_p_int,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double)c_dcapethermo(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dptlclskewt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double *arg4 = (double *) 0 ;
    double *arg5 = (double *) 0 ;
    double temp4 ;
    double temp5 ;
    
    arg4 = &temp4;
    arg5 = &temp5;
    if(!PyArg_ParseTuple(args,(char *)"ddd:c_dptlclskewt",&arg1,&arg2,&arg3)) goto fail;
    c_dptlclskewt(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dtmrskewt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:c_dtmrskewt",&arg1,&arg2)) goto fail;
    result = (double)c_dtmrskewt(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dtdaskewt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:c_dtdaskewt",&arg1,&arg2)) goto fail;
    result = (double)c_dtdaskewt(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dsatlftskewt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:c_dsatlftskewt",&arg1,&arg2)) goto fail;
    result = (double)c_dsatlftskewt(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dshowalskewt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    double *arg2 = (double *) 0 ;
    double *arg3 = (double *) 0 ;
    int arg4 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOi:c_dshowalskewt",&obj0,&obj1,&obj2,&arg4)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj0,PyArray_DOUBLE,0,0);
        arg1 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj2,PyArray_DOUBLE,0,0);
        arg3 = (double *) arr->data;
    }
    result = (double)c_dshowalskewt(arg1,arg2,arg3,arg4);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_c_dpwskewt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:c_dpwskewt",&obj0,&obj1,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj0,PyArray_DOUBLE,0,0);
        arg1 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj1,PyArray_DOUBLE,0,0);
        arg2 = (double *) arr->data;
    }
    result = (double)c_dpwskewt(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_pvoid(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    void *result;
    
    if(!PyArg_ParseTuple(args,(char *)":pvoid")) goto fail;
    result = (void *)pvoid();
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_void, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_set_nglRes_i(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:set_nglRes_i",&arg1,&arg2)) goto fail;
    set_nglRes_i(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_nglRes_i(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:get_nglRes_i",&arg1)) goto fail;
    result = (int)get_nglRes_i(arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_set_nglRes_f(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"if:set_nglRes_f",&arg1,&arg2)) goto fail;
    set_nglRes_f(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_nglRes_f(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    float result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:get_nglRes_f",&arg1)) goto fail;
    result = (float)get_nglRes_f(arg1);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_set_nglRes_c(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString *arg2 = (NhlString *) 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:set_nglRes_c",&arg1,&obj1)) goto fail;
    {
        if (PyList_Check(obj1)) {
            int size = PyList_Size(obj1);
            int i = 0;
            arg2 = (NhlString *) malloc((size+1)*sizeof(char *));
            if (size == 0) {
                arg2[0] = 0;
            }
            else {
                for (i = 0; i < size; i++) {
                    PyObject *o = PyList_GetItem(obj1,i);
                    if (PyString_Check(o)) {
                        arg2[i] = PyString_AsString(PyList_GetItem(obj1,i));
                    }
                    else {
                        PyErr_SetString(PyExc_TypeError,"List must contain strings");
                        free (arg2);
                        return NULL;
                    }
                }
            }
        } else {
            PyErr_SetString(PyExc_TypeError,"Not a list");
            return NULL;
        }
    }
    set_nglRes_c(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_nglRes_c(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:get_nglRes_c",&arg1)) goto fail;
    result = (NhlString *)get_nglRes_c(arg1);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NhlString, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_set_nglRes_s(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString arg2 ;
    
    if(!PyArg_ParseTuple(args,(char *)"is:set_nglRes_s",&arg1,&arg2)) goto fail;
    set_nglRes_s(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_nglRes_s(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    NhlString result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:get_nglRes_s",&arg1)) goto fail;
    result = (NhlString)get_nglRes_s(arg1);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NglGaus_p(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int arg3 ;
    double **arg4 ;
    int result;
    double *tempx4 ;
    
    {
        arg4 = &tempx4;
    }
    if(!PyArg_ParseTuple(args,(char *)"iii:NglGaus_p",&arg1,&arg2,&arg3)) goto fail;
    result = (int)NglGaus_p(arg1,arg2,arg3,arg4);
    
    {
        resultobj = PyInt_FromLong ((long) result);
    }
    {
        int dims[2];
        PyObject *o;
        dims[0] = arg2;
        dims[1] = arg3;
        o = (PyObject *)PyArray_FromDimsAndData(2,dims,PyArray_DOUBLE,
        (char *) arg4[0]);
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NglVinth2p(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    double **arg5 ;
    double *arg6 = (double *) 0 ;
    double *arg7 = (double *) 0 ;
    double arg8 ;
    double *arg9 = (double *) 0 ;
    double *arg10 = (double *) 0 ;
    int arg11 ;
    int arg12 ;
    double *arg13 = (double *) 0 ;
    double arg14 ;
    int arg15 ;
    int arg16 ;
    int arg17 ;
    double *tempx5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj11 = 0 ;
    
    {
        arg5 = &tempx5;
    }
    if(!PyArg_ParseTuple(args,(char *)"OiiiOOdOOiiOdiii:NglVinth2p",&obj0,&arg2,&arg3,&arg4,&obj4,&obj5,&arg8,&obj7,&obj8,&arg11,&arg12,&obj11,&arg14,&arg15,&arg16,&arg17)) goto fail;
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj0,PyArray_DOUBLE,0,0);
        arg1 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj4,PyArray_DOUBLE,0,0);
        arg6 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj5,PyArray_DOUBLE,0,0);
        arg7 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj7,PyArray_DOUBLE,0,0);
        arg9 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj8,PyArray_DOUBLE,0,0);
        arg10 = (double *) arr->data;
    }
    {
        PyArrayObject *arr;
        arr =
        (PyArrayObject *) PyArray_ContiguousFromObject(obj11,PyArray_DOUBLE,0,0);
        arg13 = (double *) arr->data;
    }
    NglVinth2p(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int dims[3];
        PyObject *o;
        dims[0] = arg2;
        dims[1] = arg3;
        dims[2] = arg4;
        o = (PyObject *)PyArray_FromDimsAndData(3,dims,PyArray_DOUBLE,
        (char *) arg5[0]);
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"new_intp", _wrap_new_intp, METH_VARARGS },
	 { (char *)"copy_intp", _wrap_copy_intp, METH_VARARGS },
	 { (char *)"delete_intp", _wrap_delete_intp, METH_VARARGS },
	 { (char *)"intp_assign", _wrap_intp_assign, METH_VARARGS },
	 { (char *)"intp_value", _wrap_intp_value, METH_VARARGS },
	 { (char *)"new_floatArray", _wrap_new_floatArray, METH_VARARGS },
	 { (char *)"delete_floatArray", _wrap_delete_floatArray, METH_VARARGS },
	 { (char *)"floatArray_getitem", _wrap_floatArray_getitem, METH_VARARGS },
	 { (char *)"floatArray_setitem", _wrap_floatArray_setitem, METH_VARARGS },
	 { (char *)"_NGGetNCARGEnv", _wrap__NGGetNCARGEnv, METH_VARARGS },
	 { (char *)"NhlInitialize", _wrap_NhlInitialize, METH_VARARGS },
	 { (char *)"NhlClose", _wrap_NhlClose, METH_VARARGS },
	 { (char *)"NhlRLClear", _wrap_NhlRLClear, METH_VARARGS },
	 { (char *)"NhlSetValues", _wrap_NhlSetValues, METH_VARARGS },
	 { (char *)"NhlRLSetString", _wrap_NhlRLSetString, METH_VARARGS },
	 { (char *)"NhlRLSetFloat", _wrap_NhlRLSetFloat, METH_VARARGS },
	 { (char *)"NhlRLSetDouble", _wrap_NhlRLSetDouble, METH_VARARGS },
	 { (char *)"NhlRLSetInteger", _wrap_NhlRLSetInteger, METH_VARARGS },
	 { (char *)"NhlNDCPolyline", _wrap_NhlNDCPolyline, METH_VARARGS },
	 { (char *)"NhlNDCPolymarker", _wrap_NhlNDCPolymarker, METH_VARARGS },
	 { (char *)"NhlNDCPolygon", _wrap_NhlNDCPolygon, METH_VARARGS },
	 { (char *)"NhlDataPolyline", _wrap_NhlDataPolyline, METH_VARARGS },
	 { (char *)"NhlDataPolymarker", _wrap_NhlDataPolymarker, METH_VARARGS },
	 { (char *)"NhlDataPolygon", _wrap_NhlDataPolygon, METH_VARARGS },
	 { (char *)"NhlDraw", _wrap_NhlDraw, METH_VARARGS },
	 { (char *)"NhlFreeColor", _wrap_NhlFreeColor, METH_VARARGS },
	 { (char *)"NhlGetGksCi", _wrap_NhlGetGksCi, METH_VARARGS },
	 { (char *)"NhlGetWorkspaceObjectId", _wrap_NhlGetWorkspaceObjectId, METH_VARARGS },
	 { (char *)"NhlIsAllocatedColor", _wrap_NhlIsAllocatedColor, METH_VARARGS },
	 { (char *)"NhlIsApp", _wrap_NhlIsApp, METH_VARARGS },
	 { (char *)"NhlIsDataComm", _wrap_NhlIsDataComm, METH_VARARGS },
	 { (char *)"NhlIsDataItem", _wrap_NhlIsDataItem, METH_VARARGS },
	 { (char *)"NhlIsDataSpec", _wrap_NhlIsDataSpec, METH_VARARGS },
	 { (char *)"NhlRLIsSet", _wrap_NhlRLIsSet, METH_VARARGS },
	 { (char *)"NhlRLUnSet", _wrap_NhlRLUnSet, METH_VARARGS },
	 { (char *)"NhlIsTransform", _wrap_NhlIsTransform, METH_VARARGS },
	 { (char *)"NhlIsView", _wrap_NhlIsView, METH_VARARGS },
	 { (char *)"NhlIsWorkstation", _wrap_NhlIsWorkstation, METH_VARARGS },
	 { (char *)"NhlName", _wrap_NhlName, METH_VARARGS },
	 { (char *)"NhlNewColor", _wrap_NhlNewColor, METH_VARARGS },
	 { (char *)"NhlSetColor", _wrap_NhlSetColor, METH_VARARGS },
	 { (char *)"NhlUpdateData", _wrap_NhlUpdateData, METH_VARARGS },
	 { (char *)"NhlUpdateWorkstation", _wrap_NhlUpdateWorkstation, METH_VARARGS },
	 { (char *)"NhlOpen", _wrap_NhlOpen, METH_VARARGS },
	 { (char *)"NhlCreate", _wrap_NhlCreate, METH_VARARGS },
	 { (char *)"NhlRLCreate", _wrap_NhlRLCreate, METH_VARARGS },
	 { (char *)"NhlFrame", _wrap_NhlFrame, METH_VARARGS },
	 { (char *)"NhlDestroy", _wrap_NhlDestroy, METH_VARARGS },
	 { (char *)"NhlRLSetMDIntegerArray", _wrap_NhlRLSetMDIntegerArray, METH_VARARGS },
	 { (char *)"NhlRLSetMDDoubleArray", _wrap_NhlRLSetMDDoubleArray, METH_VARARGS },
	 { (char *)"NhlRLSetMDFloatArray", _wrap_NhlRLSetMDFloatArray, METH_VARARGS },
	 { (char *)"NhlRLSetFloatArray", _wrap_NhlRLSetFloatArray, METH_VARARGS },
	 { (char *)"NhlRLSetIntegerArray", _wrap_NhlRLSetIntegerArray, METH_VARARGS },
	 { (char *)"NhlRLSetStringArray", _wrap_NhlRLSetStringArray, METH_VARARGS },
	 { (char *)"NhlGetValues", _wrap_NhlGetValues, METH_VARARGS },
	 { (char *)"NhlGetFloat", _wrap_NhlGetFloat, METH_VARARGS },
	 { (char *)"NhlGetFloatArray", _wrap_NhlGetFloatArray, METH_VARARGS },
	 { (char *)"NhlGetInteger", _wrap_NhlGetInteger, METH_VARARGS },
	 { (char *)"NhlGetIntegerArray", _wrap_NhlGetIntegerArray, METH_VARARGS },
	 { (char *)"NhlGetDouble", _wrap_NhlGetDouble, METH_VARARGS },
	 { (char *)"NhlGetDoubleArray", _wrap_NhlGetDoubleArray, METH_VARARGS },
	 { (char *)"NhlAddOverlay", _wrap_NhlAddOverlay, METH_VARARGS },
	 { (char *)"NhlClearWorkstation", _wrap_NhlClearWorkstation, METH_VARARGS },
	 { (char *)"NhlRemoveAnnotation", _wrap_NhlRemoveAnnotation, METH_VARARGS },
	 { (char *)"NhlAddAnnotation", _wrap_NhlAddAnnotation, METH_VARARGS },
	 { (char *)"NhlAppGetDefaultParentId", _wrap_NhlAppGetDefaultParentId, METH_VARARGS },
	 { (char *)"NhlClassName", _wrap_NhlClassName, METH_VARARGS },
	 { (char *)"NhlGetString", _wrap_NhlGetString, METH_VARARGS },
	 { (char *)"NhlAddData", _wrap_NhlAddData, METH_VARARGS },
	 { (char *)"NhlRemoveData", _wrap_NhlRemoveData, METH_VARARGS },
	 { (char *)"NhlRemoveOverlay", _wrap_NhlRemoveOverlay, METH_VARARGS },
	 { (char *)"NhlGetStringArray", _wrap_NhlGetStringArray, METH_VARARGS },
	 { (char *)"NhlRLDestroy", _wrap_NhlRLDestroy, METH_VARARGS },
	 { (char *)"NhlGetNamedColorIndex", _wrap_NhlGetNamedColorIndex, METH_VARARGS },
	 { (char *)"NhlGetBB", _wrap_NhlGetBB, METH_VARARGS },
	 { (char *)"NhlChangeWorkstation", _wrap_NhlChangeWorkstation, METH_VARARGS },
	 { (char *)"NhlPGetBB", _wrap_NhlPGetBB, METH_VARARGS },
	 { (char *)"NhlPNDCToData", _wrap_NhlPNDCToData, METH_VARARGS },
	 { (char *)"NhlPDataToNDC", _wrap_NhlPDataToNDC, METH_VARARGS },
	 { (char *)"NhlGetMDFloatArray", _wrap_NhlGetMDFloatArray, METH_VARARGS },
	 { (char *)"NhlGetMDDoubleArray", _wrap_NhlGetMDDoubleArray, METH_VARARGS },
	 { (char *)"NhlGetMDIntegerArray", _wrap_NhlGetMDIntegerArray, METH_VARARGS },
	 { (char *)"NhlPAppClass", _wrap_NhlPAppClass, METH_VARARGS },
	 { (char *)"NhlPNcgmWorkstationClass", _wrap_NhlPNcgmWorkstationClass, METH_VARARGS },
	 { (char *)"NhlPXWorkstationClass", _wrap_NhlPXWorkstationClass, METH_VARARGS },
	 { (char *)"NhlPPSWorkstationClass", _wrap_NhlPPSWorkstationClass, METH_VARARGS },
	 { (char *)"NhlPPDFWorkstationClass", _wrap_NhlPPDFWorkstationClass, METH_VARARGS },
	 { (char *)"NhlPLogLinPlotClass", _wrap_NhlPLogLinPlotClass, METH_VARARGS },
	 { (char *)"NhlPGraphicStyleClass", _wrap_NhlPGraphicStyleClass, METH_VARARGS },
	 { (char *)"NhlPScalarFieldClass", _wrap_NhlPScalarFieldClass, METH_VARARGS },
	 { (char *)"NhlPContourPlotClass", _wrap_NhlPContourPlotClass, METH_VARARGS },
	 { (char *)"NhlPtextItemClass", _wrap_NhlPtextItemClass, METH_VARARGS },
	 { (char *)"NhlPscalarFieldClass", _wrap_NhlPscalarFieldClass, METH_VARARGS },
	 { (char *)"NhlPmapPlotClass", _wrap_NhlPmapPlotClass, METH_VARARGS },
	 { (char *)"NhlPcoordArraysClass", _wrap_NhlPcoordArraysClass, METH_VARARGS },
	 { (char *)"NhlPxyPlotClass", _wrap_NhlPxyPlotClass, METH_VARARGS },
	 { (char *)"NhlPtickMarkClass", _wrap_NhlPtickMarkClass, METH_VARARGS },
	 { (char *)"NhlPtitleClass", _wrap_NhlPtitleClass, METH_VARARGS },
	 { (char *)"NhlPlabelBarClass", _wrap_NhlPlabelBarClass, METH_VARARGS },
	 { (char *)"NhlPlegendClass", _wrap_NhlPlegendClass, METH_VARARGS },
	 { (char *)"NhlPvectorFieldClass", _wrap_NhlPvectorFieldClass, METH_VARARGS },
	 { (char *)"NhlPvectorPlotClass", _wrap_NhlPvectorPlotClass, METH_VARARGS },
	 { (char *)"NhlPstreamlinePlotClass", _wrap_NhlPstreamlinePlotClass, METH_VARARGS },
	 { (char *)"NGGetNCARGEnv", _wrap_NGGetNCARGEnv, METH_VARARGS },
	 { (char *)"set_PCMP04", _wrap_set_PCMP04, METH_VARARGS },
	 { (char *)"gendat", _wrap_gendat, METH_VARARGS },
	 { (char *)"gactivate_ws", _wrap_gactivate_ws, METH_VARARGS },
	 { (char *)"gdeactivate_ws", _wrap_gdeactivate_ws, METH_VARARGS },
	 { (char *)"bndary", _wrap_bndary, METH_VARARGS },
	 { (char *)"c_plotif", _wrap_c_plotif, METH_VARARGS },
	 { (char *)"c_cpseti", _wrap_c_cpseti, METH_VARARGS },
	 { (char *)"c_cpsetr", _wrap_c_cpsetr, METH_VARARGS },
	 { (char *)"c_pcseti", _wrap_c_pcseti, METH_VARARGS },
	 { (char *)"c_pcsetr", _wrap_c_pcsetr, METH_VARARGS },
	 { (char *)"c_set", _wrap_c_set, METH_VARARGS },
	 { (char *)"c_cprect", _wrap_c_cprect, METH_VARARGS },
	 { (char *)"c_cpcldr", _wrap_c_cpcldr, METH_VARARGS },
	 { (char *)"c_plchhq", _wrap_c_plchhq, METH_VARARGS },
	 { (char *)"open_wks_wrap", _wrap_open_wks_wrap, METH_VARARGS },
	 { (char *)"labelbar_ndc_wrap", _wrap_labelbar_ndc_wrap, METH_VARARGS },
	 { (char *)"legend_ndc_wrap", _wrap_legend_ndc_wrap, METH_VARARGS },
	 { (char *)"contour_wrap", _wrap_contour_wrap, METH_VARARGS },
	 { (char *)"map_wrap", _wrap_map_wrap, METH_VARARGS },
	 { (char *)"contour_map_wrap", _wrap_contour_map_wrap, METH_VARARGS },
	 { (char *)"xy_wrap", _wrap_xy_wrap, METH_VARARGS },
	 { (char *)"y_wrap", _wrap_y_wrap, METH_VARARGS },
	 { (char *)"vector_wrap", _wrap_vector_wrap, METH_VARARGS },
	 { (char *)"vector_map_wrap", _wrap_vector_map_wrap, METH_VARARGS },
	 { (char *)"vector_scalar_wrap", _wrap_vector_scalar_wrap, METH_VARARGS },
	 { (char *)"vector_scalar_map_wrap", _wrap_vector_scalar_map_wrap, METH_VARARGS },
	 { (char *)"streamline_wrap", _wrap_streamline_wrap, METH_VARARGS },
	 { (char *)"streamline_map_wrap", _wrap_streamline_map_wrap, METH_VARARGS },
	 { (char *)"text_ndc_wrap", _wrap_text_ndc_wrap, METH_VARARGS },
	 { (char *)"text_wrap", _wrap_text_wrap, METH_VARARGS },
	 { (char *)"add_text_wrap", _wrap_add_text_wrap, METH_VARARGS },
	 { (char *)"poly_wrap", _wrap_poly_wrap, METH_VARARGS },
	 { (char *)"add_poly_wrap", _wrap_add_poly_wrap, METH_VARARGS },
	 { (char *)"panel_wrap", _wrap_panel_wrap, METH_VARARGS },
	 { (char *)"mapgci", _wrap_mapgci, METH_VARARGS },
	 { (char *)"dcapethermo", _wrap_dcapethermo, METH_VARARGS },
	 { (char *)"draw_colormap_wrap", _wrap_draw_colormap_wrap, METH_VARARGS },
	 { (char *)"natgridc", _wrap_natgridc, METH_VARARGS },
	 { (char *)"ftcurvc", _wrap_ftcurvc, METH_VARARGS },
	 { (char *)"ftcurvpc", _wrap_ftcurvpc, METH_VARARGS },
	 { (char *)"ftcurvpic", _wrap_ftcurvpic, METH_VARARGS },
	 { (char *)"c_rgbhls", _wrap_c_rgbhls, METH_VARARGS },
	 { (char *)"c_hlsrgb", _wrap_c_hlsrgb, METH_VARARGS },
	 { (char *)"c_rgbhsv", _wrap_c_rgbhsv, METH_VARARGS },
	 { (char *)"c_hsvrgb", _wrap_c_hsvrgb, METH_VARARGS },
	 { (char *)"c_rgbyiq", _wrap_c_rgbyiq, METH_VARARGS },
	 { (char *)"c_yiqrgb", _wrap_c_yiqrgb, METH_VARARGS },
	 { (char *)"c_wmbarbp", _wrap_c_wmbarbp, METH_VARARGS },
	 { (char *)"c_wmsetip", _wrap_c_wmsetip, METH_VARARGS },
	 { (char *)"c_wmsetrp", _wrap_c_wmsetrp, METH_VARARGS },
	 { (char *)"c_wmsetcp", _wrap_c_wmsetcp, METH_VARARGS },
	 { (char *)"c_wmgetip", _wrap_c_wmgetip, METH_VARARGS },
	 { (char *)"c_wmgetrp", _wrap_c_wmgetrp, METH_VARARGS },
	 { (char *)"c_wmgetcp", _wrap_c_wmgetcp, METH_VARARGS },
	 { (char *)"c_nnseti", _wrap_c_nnseti, METH_VARARGS },
	 { (char *)"c_nnsetrd", _wrap_c_nnsetrd, METH_VARARGS },
	 { (char *)"c_nnsetc", _wrap_c_nnsetc, METH_VARARGS },
	 { (char *)"c_nngeti", _wrap_c_nngeti, METH_VARARGS },
	 { (char *)"c_nngetrd", _wrap_c_nngetrd, METH_VARARGS },
	 { (char *)"c_nngetcp", _wrap_c_nngetcp, METH_VARARGS },
	 { (char *)"c_dgcdist", _wrap_c_dgcdist, METH_VARARGS },
	 { (char *)"c_dcapethermo", _wrap_c_dcapethermo, METH_VARARGS },
	 { (char *)"c_dptlclskewt", _wrap_c_dptlclskewt, METH_VARARGS },
	 { (char *)"c_dtmrskewt", _wrap_c_dtmrskewt, METH_VARARGS },
	 { (char *)"c_dtdaskewt", _wrap_c_dtdaskewt, METH_VARARGS },
	 { (char *)"c_dsatlftskewt", _wrap_c_dsatlftskewt, METH_VARARGS },
	 { (char *)"c_dshowalskewt", _wrap_c_dshowalskewt, METH_VARARGS },
	 { (char *)"c_dpwskewt", _wrap_c_dpwskewt, METH_VARARGS },
	 { (char *)"pvoid", _wrap_pvoid, METH_VARARGS },
	 { (char *)"set_nglRes_i", _wrap_set_nglRes_i, METH_VARARGS },
	 { (char *)"get_nglRes_i", _wrap_get_nglRes_i, METH_VARARGS },
	 { (char *)"set_nglRes_f", _wrap_set_nglRes_f, METH_VARARGS },
	 { (char *)"get_nglRes_f", _wrap_get_nglRes_f, METH_VARARGS },
	 { (char *)"set_nglRes_c", _wrap_set_nglRes_c, METH_VARARGS },
	 { (char *)"get_nglRes_c", _wrap_get_nglRes_c, METH_VARARGS },
	 { (char *)"set_nglRes_s", _wrap_set_nglRes_s, METH_VARARGS },
	 { (char *)"get_nglRes_s", _wrap_get_nglRes_s, METH_VARARGS },
	 { (char *)"NglGaus_p", _wrap_NglGaus_p, METH_VARARGS },
	 { (char *)"NglVinth2p", _wrap_NglVinth2p, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_NhlClass[] = {{"_p_NhlClass", 0, "NhlClass *", 0},{"_p_NhlClass"},{0}};
static swig_type_info _swigt__p_float[] = {{"_p_float", 0, "float *", 0},{"_p_float"},{0}};
static swig_type_info _swigt__p_ResInfo[] = {{"_p_ResInfo", 0, "ResInfo *", 0},{"_p_ResInfo"},{0}};
static swig_type_info _swigt__p_nglPlotId[] = {{"_p_nglPlotId", 0, "nglPlotId *", 0},{"_p_nglPlotId"},{0}};
static swig_type_info _swigt__p_p_float[] = {{"_p_p_float", 0, "float **", 0},{"_p_p_float"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0},{"_p_double"},{0}};
static swig_type_info _swigt__p_p_double[] = {{"_p_p_double", 0, "double **", 0},{"_p_p_double"},{0}};
static swig_type_info _swigt__p_NhlString[] = {{"_p_NhlString", 0, "NhlString *", 0},{"_p_NhlString"},{0}};
static swig_type_info _swigt__p_NhlBoundingBox[] = {{"_p_NhlBoundingBox", 0, "NhlBoundingBox *", 0},{"_p_NhlBoundingBox"},{0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *", 0},{"_p_void"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0},{"_p_int"},{0}};
static swig_type_info _swigt__p_nglRes[] = {{"_p_nglRes", 0, "nglRes *", 0},{"_p_nglRes"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_NhlClass, 
_swigt__p_float, 
_swigt__p_ResInfo, 
_swigt__p_nglPlotId, 
_swigt__p_p_float, 
_swigt__p_double, 
_swigt__p_p_double, 
_swigt__p_NhlString, 
_swigt__p_NhlBoundingBox, 
_swigt__p_void, 
_swigt__p_int, 
_swigt__p_nglRes, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_INT,     (char *)"NhlBACKGROUND", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlTOPLEFT", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlCENTERLEFT", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlBOTTOMLEFT", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlTOPCENTER", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlCENTERCENTER", (long) 4, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlBOTTOMCENTER", (long) 5, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlTOPRIGHT", (long) 6, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlCENTERRIGHT", (long) 7, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlBOTTOMRIGHT", (long) 8, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkOrientation", 0, 0, (void *)"wkOrientation", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamDataXF", 0, 0, (void *)"amDataXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamDataYF", 0, 0, (void *)"amDataYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamJust", 0, 0, (void *)"amJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamOn", 0, 0, (void *)"amOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamOrthogonalPosF", 0, 0, (void *)"amOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamParallelPosF", 0, 0, (void *)"amParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamResizeNotify", 0, 0, (void *)"amResizeNotify", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamSide", 0, 0, (void *)"amSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamTrackData", 0, 0, (void *)"amTrackData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamViewId", 0, 0, (void *)"amViewId", 0},
{ SWIG_PY_STRING,  (char*)"NhlNamZone", 0, 0, (void *)"amZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNappDefaultParent", 0, 0, (void *)"appDefaultParent", 0},
{ SWIG_PY_STRING,  (char*)"NhlNappFileSuffix", 0, 0, (void *)"appFileSuffix", 0},
{ SWIG_PY_STRING,  (char*)"NhlNappResources", 0, 0, (void *)"appResources", 0},
{ SWIG_PY_STRING,  (char*)"NhlNappSysDir", 0, 0, (void *)"appSysDir", 0},
{ SWIG_PY_STRING,  (char*)"NhlNappUsrDir", 0, 0, (void *)"appUsrDir", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaCopyArrays", 0, 0, (void *)"caCopyArrays", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaXArray", 0, 0, (void *)"caXArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaXCast", 0, 0, (void *)"caXCast", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaXMaxV", 0, 0, (void *)"caXMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaXMinV", 0, 0, (void *)"caXMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaXMissingV", 0, 0, (void *)"caXMissingV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaYArray", 0, 0, (void *)"caYArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaYCast", 0, 0, (void *)"caYCast", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaYMaxV", 0, 0, (void *)"caYMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaYMinV", 0, 0, (void *)"caYMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcaYMissingV", 0, 0, (void *)"caYMissingV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConpackParams", 0, 0, (void *)"cnConpackParams", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelAngleF", 0, 0, (void *)"cnConstFLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelBackgroundColor", 0, 0, (void *)"cnConstFLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelConstantSpacingF", 0, 0, (void *)"cnConstFLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFont", 0, 0, (void *)"cnConstFLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFontAspectF", 0, 0, (void *)"cnConstFLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFontColor", 0, 0, (void *)"cnConstFLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFontHeightF", 0, 0, (void *)"cnConstFLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFontQuality", 0, 0, (void *)"cnConstFLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFontThicknessF", 0, 0, (void *)"cnConstFLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFormat", 0, 0, (void *)"cnConstFLabelFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelFuncCode", 0, 0, (void *)"cnConstFLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelJust", 0, 0, (void *)"cnConstFLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelOn", 0, 0, (void *)"cnConstFLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelOrthogonalPosF", 0, 0, (void *)"cnConstFLabelOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelParallelPosF", 0, 0, (void *)"cnConstFLabelParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelPerimColor", 0, 0, (void *)"cnConstFLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelPerimOn", 0, 0, (void *)"cnConstFLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelPerimSpaceF", 0, 0, (void *)"cnConstFLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelPerimThicknessF", 0, 0, (void *)"cnConstFLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelSide", 0, 0, (void *)"cnConstFLabelSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelString", 0, 0, (void *)"cnConstFLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelTextDirection", 0, 0, (void *)"cnConstFLabelTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFLabelZone", 0, 0, (void *)"cnConstFLabelZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnConstFUseInfoLabelRes", 0, 0, (void *)"cnConstFUseInfoLabelRes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnExplicitLabelBarLabelsOn", 0, 0, (void *)"cnExplicitLabelBarLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnExplicitLegendLabelsOn", 0, 0, (void *)"cnExplicitLegendLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnExplicitLineLabelsOn", 0, 0, (void *)"cnExplicitLineLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillBackgroundColor", 0, 0, (void *)"cnFillBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillColor", 0, 0, (void *)"cnFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillColors", 0, 0, (void *)"cnFillColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillDrawOrder", 0, 0, (void *)"cnFillDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillOn", 0, 0, (void *)"cnFillOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillPattern", 0, 0, (void *)"cnFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillPatterns", 0, 0, (void *)"cnFillPatterns", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillScaleF", 0, 0, (void *)"cnFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFillScales", 0, 0, (void *)"cnFillScales", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnFixFillBleed", 0, 0, (void *)"cnFixFillBleed", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnGridBoundPerimColor", 0, 0, (void *)"cnGridBoundPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnGridBoundPerimDashPattern", 0, 0, (void *)"cnGridBoundPerimDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnGridBoundPerimOn", 0, 0, (void *)"cnGridBoundPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnGridBoundPerimThicknessF", 0, 0, (void *)"cnGridBoundPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelAngleF", 0, 0, (void *)"cnHighLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelBackgroundColor", 0, 0, (void *)"cnHighLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelConstantSpacingF", 0, 0, (void *)"cnHighLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFont", 0, 0, (void *)"cnHighLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFontAspectF", 0, 0, (void *)"cnHighLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFontColor", 0, 0, (void *)"cnHighLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFontHeightF", 0, 0, (void *)"cnHighLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFontQuality", 0, 0, (void *)"cnHighLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFontThicknessF", 0, 0, (void *)"cnHighLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFormat", 0, 0, (void *)"cnHighLabelFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelFuncCode", 0, 0, (void *)"cnHighLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelPerimColor", 0, 0, (void *)"cnHighLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelPerimOn", 0, 0, (void *)"cnHighLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelPerimSpaceF", 0, 0, (void *)"cnHighLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelPerimThicknessF", 0, 0, (void *)"cnHighLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelString", 0, 0, (void *)"cnHighLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLabelsOn", 0, 0, (void *)"cnHighLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighLowLabelOverlapMode", 0, 0, (void *)"cnHighLowLabelOverlapMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnHighUseLineLabelRes", 0, 0, (void *)"cnHighUseLineLabelRes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelAngleF", 0, 0, (void *)"cnInfoLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelBackgroundColor", 0, 0, (void *)"cnInfoLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelConstantSpacingF", 0, 0, (void *)"cnInfoLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFont", 0, 0, (void *)"cnInfoLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFontAspectF", 0, 0, (void *)"cnInfoLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFontColor", 0, 0, (void *)"cnInfoLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFontHeightF", 0, 0, (void *)"cnInfoLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFontQuality", 0, 0, (void *)"cnInfoLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFontThicknessF", 0, 0, (void *)"cnInfoLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFormat", 0, 0, (void *)"cnInfoLabelFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelFuncCode", 0, 0, (void *)"cnInfoLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelJust", 0, 0, (void *)"cnInfoLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelOn", 0, 0, (void *)"cnInfoLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelOrthogonalPosF", 0, 0, (void *)"cnInfoLabelOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelParallelPosF", 0, 0, (void *)"cnInfoLabelParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelPerimColor", 0, 0, (void *)"cnInfoLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelPerimOn", 0, 0, (void *)"cnInfoLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelPerimSpaceF", 0, 0, (void *)"cnInfoLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelPerimThicknessF", 0, 0, (void *)"cnInfoLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelSide", 0, 0, (void *)"cnInfoLabelSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelString", 0, 0, (void *)"cnInfoLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelTextDirection", 0, 0, (void *)"cnInfoLabelTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnInfoLabelZone", 0, 0, (void *)"cnInfoLabelZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLabelBarEndLabelsOn", 0, 0, (void *)"cnLabelBarEndLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLabelDrawOrder", 0, 0, (void *)"cnLabelDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLabelMasking", 0, 0, (void *)"cnLabelMasking", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLabelScaleFactorF", 0, 0, (void *)"cnLabelScaleFactorF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLabelScaleValueF", 0, 0, (void *)"cnLabelScaleValueF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLabelScalingMode", 0, 0, (void *)"cnLabelScalingMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLegendLevelFlags", 0, 0, (void *)"cnLegendLevelFlags", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLevelCount", 0, 0, (void *)"cnLevelCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLevelFlag", 0, 0, (void *)"cnLevelFlag", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLevelFlags", 0, 0, (void *)"cnLevelFlags", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLevelSelectionMode", 0, 0, (void *)"cnLevelSelectionMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLevelSpacingF", 0, 0, (void *)"cnLevelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLevels", 0, 0, (void *)"cnLevels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineColor", 0, 0, (void *)"cnLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineColors", 0, 0, (void *)"cnLineColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineDashPattern", 0, 0, (void *)"cnLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineDashPatterns", 0, 0, (void *)"cnLineDashPatterns", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineDashSegLenF", 0, 0, (void *)"cnLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineDrawOrder", 0, 0, (void *)"cnLineDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelAngleF", 0, 0, (void *)"cnLineLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelBackgroundColor", 0, 0, (void *)"cnLineLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelConstantSpacingF", 0, 0, (void *)"cnLineLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFont", 0, 0, (void *)"cnLineLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFontAspectF", 0, 0, (void *)"cnLineLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFontColor", 0, 0, (void *)"cnLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFontColors", 0, 0, (void *)"cnLineLabelFontColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFontHeightF", 0, 0, (void *)"cnLineLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFontQuality", 0, 0, (void *)"cnLineLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFontThicknessF", 0, 0, (void *)"cnLineLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFormat", 0, 0, (void *)"cnLineLabelFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelFuncCode", 0, 0, (void *)"cnLineLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelInterval", 0, 0, (void *)"cnLineLabelInterval", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelPerimColor", 0, 0, (void *)"cnLineLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelPerimOn", 0, 0, (void *)"cnLineLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelPerimSpaceF", 0, 0, (void *)"cnLineLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelPerimThicknessF", 0, 0, (void *)"cnLineLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelPlacementMode", 0, 0, (void *)"cnLineLabelPlacementMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelStrings", 0, 0, (void *)"cnLineLabelStrings", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineLabelsOn", 0, 0, (void *)"cnLineLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineThicknessF", 0, 0, (void *)"cnLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLineThicknesses", 0, 0, (void *)"cnLineThicknesses", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLinesOn", 0, 0, (void *)"cnLinesOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelAngleF", 0, 0, (void *)"cnLowLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelBackgroundColor", 0, 0, (void *)"cnLowLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelConstantSpacingF", 0, 0, (void *)"cnLowLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFont", 0, 0, (void *)"cnLowLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFontAspectF", 0, 0, (void *)"cnLowLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFontColor", 0, 0, (void *)"cnLowLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFontHeightF", 0, 0, (void *)"cnLowLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFontQuality", 0, 0, (void *)"cnLowLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFontThicknessF", 0, 0, (void *)"cnLowLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFormat", 0, 0, (void *)"cnLowLabelFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelFuncCode", 0, 0, (void *)"cnLowLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelPerimColor", 0, 0, (void *)"cnLowLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelPerimOn", 0, 0, (void *)"cnLowLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelPerimSpaceF", 0, 0, (void *)"cnLowLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelPerimThicknessF", 0, 0, (void *)"cnLowLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelString", 0, 0, (void *)"cnLowLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowLabelsOn", 0, 0, (void *)"cnLowLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnLowUseHighLabelRes", 0, 0, (void *)"cnLowUseHighLabelRes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMaxDataValueFormat", 0, 0, (void *)"cnMaxDataValueFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMaxLevelCount", 0, 0, (void *)"cnMaxLevelCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMaxLevelValF", 0, 0, (void *)"cnMaxLevelValF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMaxPointDistanceF", 0, 0, (void *)"cnMaxPointDistanceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMinLevelValF", 0, 0, (void *)"cnMinLevelValF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValFillColor", 0, 0, (void *)"cnMissingValFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValFillPattern", 0, 0, (void *)"cnMissingValFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValFillScaleF", 0, 0, (void *)"cnMissingValFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValPerimColor", 0, 0, (void *)"cnMissingValPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValPerimDashPattern", 0, 0, (void *)"cnMissingValPerimDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValPerimGridBoundOn", 0, 0, (void *)"cnMissingValPerimGridBoundOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValPerimOn", 0, 0, (void *)"cnMissingValPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMissingValPerimThicknessF", 0, 0, (void *)"cnMissingValPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoFillColor", 0, 0, (void *)"cnMonoFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoFillPattern", 0, 0, (void *)"cnMonoFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoFillScale", 0, 0, (void *)"cnMonoFillScale", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoLevelFlag", 0, 0, (void *)"cnMonoLevelFlag", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoLineColor", 0, 0, (void *)"cnMonoLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoLineDashPattern", 0, 0, (void *)"cnMonoLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoLineLabelFontColor", 0, 0, (void *)"cnMonoLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnMonoLineThickness", 0, 0, (void *)"cnMonoLineThickness", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnNoDataLabelOn", 0, 0, (void *)"cnNoDataLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnNoDataLabelString", 0, 0, (void *)"cnNoDataLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnOutOfRangePerimColor", 0, 0, (void *)"cnOutOfRangePerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnOutOfRangePerimDashPattern", 0, 0, (void *)"cnOutOfRangePerimDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnOutOfRangePerimOn", 0, 0, (void *)"cnOutOfRangePerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnOutOfRangePerimThicknessF", 0, 0, (void *)"cnOutOfRangePerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnRasterCellSizeF", 0, 0, (void *)"cnRasterCellSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnRasterMinCellSizeF", 0, 0, (void *)"cnRasterMinCellSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnRasterModeOn", 0, 0, (void *)"cnRasterModeOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnRasterSampleFactorF", 0, 0, (void *)"cnRasterSampleFactorF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnRasterSmoothingOn", 0, 0, (void *)"cnRasterSmoothingOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnScalarFieldData", 0, 0, (void *)"cnScalarFieldData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnSmoothingDistanceF", 0, 0, (void *)"cnSmoothingDistanceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnSmoothingOn", 0, 0, (void *)"cnSmoothingOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNcnSmoothingTensionF", 0, 0, (void *)"cnSmoothingTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctCopyTables", 0, 0, (void *)"ctCopyTables", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXElementSize", 0, 0, (void *)"ctXElementSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXMaxV", 0, 0, (void *)"ctXMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXMinV", 0, 0, (void *)"ctXMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXMissingV", 0, 0, (void *)"ctXMissingV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXTable", 0, 0, (void *)"ctXTable", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXTableLengths", 0, 0, (void *)"ctXTableLengths", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctXTableType", 0, 0, (void *)"ctXTableType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYElementSize", 0, 0, (void *)"ctYElementSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYMaxV", 0, 0, (void *)"ctYMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYMinV", 0, 0, (void *)"ctYMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYMissingV", 0, 0, (void *)"ctYMissingV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYTable", 0, 0, (void *)"ctYTable", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYTableLengths", 0, 0, (void *)"ctYTableLengths", 0},
{ SWIG_PY_STRING,  (char*)"NhlNctYTableType", 0, 0, (void *)"ctYTableType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNdcDelayCompute", 0, 0, (void *)"dcDelayCompute", 0},
{ SWIG_PY_STRING,  (char*)"NhlNerrBuffer", 0, 0, (void *)"errBuffer", 0},
{ SWIG_PY_STRING,  (char*)"NhlNerrFileName", 0, 0, (void *)"errFileName", 0},
{ SWIG_PY_STRING,  (char*)"NhlNerrLevel", 0, 0, (void *)"errLevel", 0},
{ SWIG_PY_STRING,  (char*)"NhlNerrPrint", 0, 0, (void *)"errPrint", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsClipOn", 0, 0, (void *)"gsClipOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsEdgeColor", 0, 0, (void *)"gsEdgeColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsEdgeDashPattern", 0, 0, (void *)"gsEdgeDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsEdgeDashSegLenF", 0, 0, (void *)"gsEdgeDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsEdgeThicknessF", 0, 0, (void *)"gsEdgeThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsEdgesOn", 0, 0, (void *)"gsEdgesOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFillBackgroundColor", 0, 0, (void *)"gsFillBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFillColor", 0, 0, (void *)"gsFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFillIndex", 0, 0, (void *)"gsFillIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFillLineThicknessF", 0, 0, (void *)"gsFillLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFillScaleF", 0, 0, (void *)"gsFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFont", 0, 0, (void *)"gsFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFontAspectF", 0, 0, (void *)"gsFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFontColor", 0, 0, (void *)"gsFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFontHeightF", 0, 0, (void *)"gsFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFontQuality", 0, 0, (void *)"gsFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsFontThicknessF", 0, 0, (void *)"gsFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineColor", 0, 0, (void *)"gsLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineDashPattern", 0, 0, (void *)"gsLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineDashSegLenF", 0, 0, (void *)"gsLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelConstantSpacingF", 0, 0, (void *)"gsLineLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFont", 0, 0, (void *)"gsLineLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFontAspectF", 0, 0, (void *)"gsLineLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFontColor", 0, 0, (void *)"gsLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFontHeightF", 0, 0, (void *)"gsLineLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFontQuality", 0, 0, (void *)"gsLineLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFontThicknessF", 0, 0, (void *)"gsLineLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelFuncCode", 0, 0, (void *)"gsLineLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineLabelString", 0, 0, (void *)"gsLineLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsLineThicknessF", 0, 0, (void *)"gsLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsMarkerColor", 0, 0, (void *)"gsMarkerColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsMarkerIndex", 0, 0, (void *)"gsMarkerIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsMarkerSizeF", 0, 0, (void *)"gsMarkerSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsMarkerThicknessF", 0, 0, (void *)"gsMarkerThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsTextAngleF", 0, 0, (void *)"gsTextAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsTextConstantSpacingF", 0, 0, (void *)"gsTextConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsTextDirection", 0, 0, (void *)"gsTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsTextFuncCode", 0, 0, (void *)"gsTextFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNgsTextJustification", 0, 0, (void *)"gsTextJustification", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbAutoManage", 0, 0, (void *)"lbAutoManage", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBottomMarginF", 0, 0, (void *)"lbBottomMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxCount", 0, 0, (void *)"lbBoxCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxFractions", 0, 0, (void *)"lbBoxFractions", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxLineColor", 0, 0, (void *)"lbBoxLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxLineDashPattern", 0, 0, (void *)"lbBoxLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxLineDashSegLenF", 0, 0, (void *)"lbBoxLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxLineThicknessF", 0, 0, (void *)"lbBoxLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxLinesOn", 0, 0, (void *)"lbBoxLinesOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxMajorExtentF", 0, 0, (void *)"lbBoxMajorExtentF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxMinorExtentF", 0, 0, (void *)"lbBoxMinorExtentF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbBoxSizing", 0, 0, (void *)"lbBoxSizing", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillBackground", 0, 0, (void *)"lbFillBackground", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillColor", 0, 0, (void *)"lbFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillColors", 0, 0, (void *)"lbFillColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillLineThicknessF", 0, 0, (void *)"lbFillLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillPattern", 0, 0, (void *)"lbFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillPatterns", 0, 0, (void *)"lbFillPatterns", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillScaleF", 0, 0, (void *)"lbFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbFillScales", 0, 0, (void *)"lbFillScales", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbJustification", 0, 0, (void *)"lbJustification", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelAlignment", 0, 0, (void *)"lbLabelAlignment", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelAngleF", 0, 0, (void *)"lbLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelAutoStride", 0, 0, (void *)"lbLabelAutoStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelBarOn", 0, 0, (void *)"lbLabelBarOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelConstantSpacingF", 0, 0, (void *)"lbLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelDirection", 0, 0, (void *)"lbLabelDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFont", 0, 0, (void *)"lbLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFontAspectF", 0, 0, (void *)"lbLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFontColor", 0, 0, (void *)"lbLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFontHeightF", 0, 0, (void *)"lbLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFontQuality", 0, 0, (void *)"lbLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFontThicknessF", 0, 0, (void *)"lbLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelFuncCode", 0, 0, (void *)"lbLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelJust", 0, 0, (void *)"lbLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelOffsetF", 0, 0, (void *)"lbLabelOffsetF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelPosition", 0, 0, (void *)"lbLabelPosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelStride", 0, 0, (void *)"lbLabelStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelStrings", 0, 0, (void *)"lbLabelStrings", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLabelsOn", 0, 0, (void *)"lbLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbLeftMarginF", 0, 0, (void *)"lbLeftMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbMaxLabelLenF", 0, 0, (void *)"lbMaxLabelLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbMinLabelSpacingF", 0, 0, (void *)"lbMinLabelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbMonoFillColor", 0, 0, (void *)"lbMonoFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbMonoFillPattern", 0, 0, (void *)"lbMonoFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbMonoFillScale", 0, 0, (void *)"lbMonoFillScale", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbOrientation", 0, 0, (void *)"lbOrientation", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimColor", 0, 0, (void *)"lbPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimDashPattern", 0, 0, (void *)"lbPerimDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimDashSegLenF", 0, 0, (void *)"lbPerimDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimFill", 0, 0, (void *)"lbPerimFill", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimFillColor", 0, 0, (void *)"lbPerimFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimOn", 0, 0, (void *)"lbPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbPerimThicknessF", 0, 0, (void *)"lbPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbRightMarginF", 0, 0, (void *)"lbRightMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleAngleF", 0, 0, (void *)"lbTitleAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleConstantSpacingF", 0, 0, (void *)"lbTitleConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleDirection", 0, 0, (void *)"lbTitleDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleExtentF", 0, 0, (void *)"lbTitleExtentF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFont", 0, 0, (void *)"lbTitleFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFontAspectF", 0, 0, (void *)"lbTitleFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFontColor", 0, 0, (void *)"lbTitleFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFontHeightF", 0, 0, (void *)"lbTitleFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFontQuality", 0, 0, (void *)"lbTitleFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFontThicknessF", 0, 0, (void *)"lbTitleFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleFuncCode", 0, 0, (void *)"lbTitleFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleJust", 0, 0, (void *)"lbTitleJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleOffsetF", 0, 0, (void *)"lbTitleOffsetF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleOn", 0, 0, (void *)"lbTitleOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitlePosition", 0, 0, (void *)"lbTitlePosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTitleString", 0, 0, (void *)"lbTitleString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlbTopMarginF", 0, 0, (void *)"lbTopMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgAutoManage", 0, 0, (void *)"lgAutoManage", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBottomMarginF", 0, 0, (void *)"lgBottomMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxBackground", 0, 0, (void *)"lgBoxBackground", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxLineColor", 0, 0, (void *)"lgBoxLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxLineDashPattern", 0, 0, (void *)"lgBoxLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxLineDashSegLenF", 0, 0, (void *)"lgBoxLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxLineThicknessF", 0, 0, (void *)"lgBoxLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxLinesOn", 0, 0, (void *)"lgBoxLinesOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxMajorExtentF", 0, 0, (void *)"lgBoxMajorExtentF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgBoxMinorExtentF", 0, 0, (void *)"lgBoxMinorExtentF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgDashIndex", 0, 0, (void *)"lgDashIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgDashIndexes", 0, 0, (void *)"lgDashIndexes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgItemCount", 0, 0, (void *)"lgItemCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgItemPlacement", 0, 0, (void *)"lgItemPlacement", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgItemPositions", 0, 0, (void *)"lgItemPositions", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgItemType", 0, 0, (void *)"lgItemType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgItemTypes", 0, 0, (void *)"lgItemTypes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgJustification", 0, 0, (void *)"lgJustification", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelAlignment", 0, 0, (void *)"lgLabelAlignment", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelAngleF", 0, 0, (void *)"lgLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelAutoStride", 0, 0, (void *)"lgLabelAutoStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelConstantSpacingF", 0, 0, (void *)"lgLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelDirection", 0, 0, (void *)"lgLabelDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFont", 0, 0, (void *)"lgLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFontAspectF", 0, 0, (void *)"lgLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFontColor", 0, 0, (void *)"lgLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFontHeightF", 0, 0, (void *)"lgLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFontQuality", 0, 0, (void *)"lgLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFontThicknessF", 0, 0, (void *)"lgLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelFuncCode", 0, 0, (void *)"lgLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelJust", 0, 0, (void *)"lgLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelOffsetF", 0, 0, (void *)"lgLabelOffsetF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelPosition", 0, 0, (void *)"lgLabelPosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelStride", 0, 0, (void *)"lgLabelStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelStrings", 0, 0, (void *)"lgLabelStrings", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLabelsOn", 0, 0, (void *)"lgLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLeftMarginF", 0, 0, (void *)"lgLeftMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLegendOn", 0, 0, (void *)"lgLegendOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineColor", 0, 0, (void *)"lgLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineColors", 0, 0, (void *)"lgLineColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineDashSegLenF", 0, 0, (void *)"lgLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineDashSegLens", 0, 0, (void *)"lgLineDashSegLens", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelConstantSpacingF", 0, 0, (void *)"lgLineLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFont", 0, 0, (void *)"lgLineLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontAspectF", 0, 0, (void *)"lgLineLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontColor", 0, 0, (void *)"lgLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontColors", 0, 0, (void *)"lgLineLabelFontColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontHeightF", 0, 0, (void *)"lgLineLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontHeights", 0, 0, (void *)"lgLineLabelFontHeights", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontQuality", 0, 0, (void *)"lgLineLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFontThicknessF", 0, 0, (void *)"lgLineLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelFuncCode", 0, 0, (void *)"lgLineLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelStrings", 0, 0, (void *)"lgLineLabelStrings", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineLabelsOn", 0, 0, (void *)"lgLineLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineThicknessF", 0, 0, (void *)"lgLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgLineThicknesses", 0, 0, (void *)"lgLineThicknesses", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerColor", 0, 0, (void *)"lgMarkerColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerColors", 0, 0, (void *)"lgMarkerColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerIndex", 0, 0, (void *)"lgMarkerIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerIndexes", 0, 0, (void *)"lgMarkerIndexes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerSizeF", 0, 0, (void *)"lgMarkerSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerSizes", 0, 0, (void *)"lgMarkerSizes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerThicknessF", 0, 0, (void *)"lgMarkerThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMarkerThicknesses", 0, 0, (void *)"lgMarkerThicknesses", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoDashIndex", 0, 0, (void *)"lgMonoDashIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoItemType", 0, 0, (void *)"lgMonoItemType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoLineColor", 0, 0, (void *)"lgMonoLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoLineDashSegLen", 0, 0, (void *)"lgMonoLineDashSegLen", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoLineLabelFontColor", 0, 0, (void *)"lgMonoLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoLineLabelFontHeight", 0, 0, (void *)"lgMonoLineLabelFontHeight", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoLineThickness", 0, 0, (void *)"lgMonoLineThickness", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoMarkerColor", 0, 0, (void *)"lgMonoMarkerColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoMarkerIndex", 0, 0, (void *)"lgMonoMarkerIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoMarkerSize", 0, 0, (void *)"lgMonoMarkerSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgMonoMarkerThickness", 0, 0, (void *)"lgMonoMarkerThickness", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgOrientation", 0, 0, (void *)"lgOrientation", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimColor", 0, 0, (void *)"lgPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimDashPattern", 0, 0, (void *)"lgPerimDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimDashSegLenF", 0, 0, (void *)"lgPerimDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimFill", 0, 0, (void *)"lgPerimFill", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimFillColor", 0, 0, (void *)"lgPerimFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimOn", 0, 0, (void *)"lgPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgPerimThicknessF", 0, 0, (void *)"lgPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgRightMarginF", 0, 0, (void *)"lgRightMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleAngleF", 0, 0, (void *)"lgTitleAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleConstantSpacingF", 0, 0, (void *)"lgTitleConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleDirection", 0, 0, (void *)"lgTitleDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleExtentF", 0, 0, (void *)"lgTitleExtentF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFont", 0, 0, (void *)"lgTitleFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFontAspectF", 0, 0, (void *)"lgTitleFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFontColor", 0, 0, (void *)"lgTitleFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFontHeightF", 0, 0, (void *)"lgTitleFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFontQuality", 0, 0, (void *)"lgTitleFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFontThicknessF", 0, 0, (void *)"lgTitleFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleFuncCode", 0, 0, (void *)"lgTitleFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleJust", 0, 0, (void *)"lgTitleJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleOffsetF", 0, 0, (void *)"lgTitleOffsetF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleOn", 0, 0, (void *)"lgTitleOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitlePosition", 0, 0, (void *)"lgTitlePosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTitleString", 0, 0, (void *)"lgTitleString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNlgTopMarginF", 0, 0, (void *)"lgTopMarginF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpAreaGroupCount", 0, 0, (void *)"mpAreaGroupCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpAreaMaskingOn", 0, 0, (void *)"mpAreaMaskingOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpAreaNames", 0, 0, (void *)"mpAreaNames", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpAreaTypes", 0, 0, (void *)"mpAreaTypes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDataBaseVersion", 0, 0, (void *)"mpDataBaseVersion", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDataResolution", 0, 0, (void *)"mpDataResolution", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDataSetName", 0, 0, (void *)"mpDataSetName", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDefaultFillColor", 0, 0, (void *)"mpDefaultFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDefaultFillPattern", 0, 0, (void *)"mpDefaultFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDefaultFillScaleF", 0, 0, (void *)"mpDefaultFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpDynamicAreaGroups", 0, 0, (void *)"mpDynamicAreaGroups", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillAreaSpecifiers", 0, 0, (void *)"mpFillAreaSpecifiers", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillBoundarySets", 0, 0, (void *)"mpFillBoundarySets", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillColor", 0, 0, (void *)"mpFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillColors", 0, 0, (void *)"mpFillColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillDrawOrder", 0, 0, (void *)"mpFillDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillOn", 0, 0, (void *)"mpFillOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillPattern", 0, 0, (void *)"mpFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillPatternBackground", 0, 0, (void *)"mpFillPatternBackground", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillPatterns", 0, 0, (void *)"mpFillPatterns", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillScaleF", 0, 0, (void *)"mpFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFillScales", 0, 0, (void *)"mpFillScales", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpFixedAreaGroups", 0, 0, (void *)"mpFixedAreaGroups", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGeophysicalLineColor", 0, 0, (void *)"mpGeophysicalLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGeophysicalLineDashPattern", 0, 0, (void *)"mpGeophysicalLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGeophysicalLineDashSegLenF", 0, 0, (void *)"mpGeophysicalLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGeophysicalLineThicknessF", 0, 0, (void *)"mpGeophysicalLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridAndLimbDrawOrder", 0, 0, (void *)"mpGridAndLimbDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridAndLimbOn", 0, 0, (void *)"mpGridAndLimbOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridLatSpacingF", 0, 0, (void *)"mpGridLatSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridLineColor", 0, 0, (void *)"mpGridLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridLineDashPattern", 0, 0, (void *)"mpGridLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridLineDashSegLenF", 0, 0, (void *)"mpGridLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridLineThicknessF", 0, 0, (void *)"mpGridLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridLonSpacingF", 0, 0, (void *)"mpGridLonSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridMaskMode", 0, 0, (void *)"mpGridMaskMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridMaxLatF", 0, 0, (void *)"mpGridMaxLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridPolarLonSpacingF", 0, 0, (void *)"mpGridPolarLonSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGridSpacingF", 0, 0, (void *)"mpGridSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpInlandWaterFillColor", 0, 0, (void *)"mpInlandWaterFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpInlandWaterFillPattern", 0, 0, (void *)"mpInlandWaterFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpInlandWaterFillScaleF", 0, 0, (void *)"mpInlandWaterFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLabelDrawOrder", 0, 0, (void *)"mpLabelDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLabelFontColor", 0, 0, (void *)"mpLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLabelFontHeightF", 0, 0, (void *)"mpLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLabelsOn", 0, 0, (void *)"mpLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLandFillColor", 0, 0, (void *)"mpLandFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLandFillPattern", 0, 0, (void *)"mpLandFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLandFillScaleF", 0, 0, (void *)"mpLandFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLimbLineColor", 0, 0, (void *)"mpLimbLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLimbLineDashPattern", 0, 0, (void *)"mpLimbLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLimbLineDashSegLenF", 0, 0, (void *)"mpLimbLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLimbLineThicknessF", 0, 0, (void *)"mpLimbLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMaskAreaSpecifiers", 0, 0, (void *)"mpMaskAreaSpecifiers", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMonoFillColor", 0, 0, (void *)"mpMonoFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMonoFillPattern", 0, 0, (void *)"mpMonoFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMonoFillScale", 0, 0, (void *)"mpMonoFillScale", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpNationalLineColor", 0, 0, (void *)"mpNationalLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpNationalLineDashPattern", 0, 0, (void *)"mpNationalLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpNationalLineDashSegLenF", 0, 0, (void *)"mpNationalLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpNationalLineThicknessF", 0, 0, (void *)"mpNationalLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOceanFillColor", 0, 0, (void *)"mpOceanFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOceanFillPattern", 0, 0, (void *)"mpOceanFillPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOceanFillScaleF", 0, 0, (void *)"mpOceanFillScaleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOutlineBoundarySets", 0, 0, (void *)"mpOutlineBoundarySets", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOutlineDrawOrder", 0, 0, (void *)"mpOutlineDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOutlineOn", 0, 0, (void *)"mpOutlineOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpOutlineSpecifiers", 0, 0, (void *)"mpOutlineSpecifiers", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpPerimDrawOrder", 0, 0, (void *)"mpPerimDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpPerimLineColor", 0, 0, (void *)"mpPerimLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpPerimLineDashPattern", 0, 0, (void *)"mpPerimLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpPerimLineDashSegLenF", 0, 0, (void *)"mpPerimLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpPerimLineThicknessF", 0, 0, (void *)"mpPerimLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpPerimOn", 0, 0, (void *)"mpPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpShapeMode", 0, 0, (void *)"mpShapeMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSpecifiedFillColors", 0, 0, (void *)"mpSpecifiedFillColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSpecifiedFillDirectIndexing", 0, 0, (void *)"mpSpecifiedFillDirectIndexing", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSpecifiedFillPatterns", 0, 0, (void *)"mpSpecifiedFillPatterns", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSpecifiedFillPriority", 0, 0, (void *)"mpSpecifiedFillPriority", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSpecifiedFillScales", 0, 0, (void *)"mpSpecifiedFillScales", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpUSStateLineColor", 0, 0, (void *)"mpUSStateLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpUSStateLineDashPattern", 0, 0, (void *)"mpUSStateLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpUSStateLineDashSegLenF", 0, 0, (void *)"mpUSStateLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpUSStateLineThicknessF", 0, 0, (void *)"mpUSStateLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomAngleF", 0, 0, (void *)"mpBottomAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomMapPosF", 0, 0, (void *)"mpBottomMapPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomNDCF", 0, 0, (void *)"mpBottomNDCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomNPCF", 0, 0, (void *)"mpBottomNPCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomPointLatF", 0, 0, (void *)"mpBottomPointLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomPointLonF", 0, 0, (void *)"mpBottomPointLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpBottomWindowF", 0, 0, (void *)"mpBottomWindowF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpCenterLatF", 0, 0, (void *)"mpCenterLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpCenterLonF", 0, 0, (void *)"mpCenterLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpCenterRotF", 0, 0, (void *)"mpCenterRotF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpEllipticalBoundary", 0, 0, (void *)"mpEllipticalBoundary", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpGreatCircleLinesOn", 0, 0, (void *)"mpGreatCircleLinesOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLambertMeridianF", 0, 0, (void *)"mpLambertMeridianF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLambertParallel1F", 0, 0, (void *)"mpLambertParallel1F", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLambertParallel2F", 0, 0, (void *)"mpLambertParallel2F", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftAngleF", 0, 0, (void *)"mpLeftAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftCornerLatF", 0, 0, (void *)"mpLeftCornerLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftCornerLonF", 0, 0, (void *)"mpLeftCornerLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftMapPosF", 0, 0, (void *)"mpLeftMapPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftNDCF", 0, 0, (void *)"mpLeftNDCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftNPCF", 0, 0, (void *)"mpLeftNPCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftPointLatF", 0, 0, (void *)"mpLeftPointLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftPointLonF", 0, 0, (void *)"mpLeftPointLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLeftWindowF", 0, 0, (void *)"mpLeftWindowF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpLimitMode", 0, 0, (void *)"mpLimitMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMaxLatF", 0, 0, (void *)"mpMaxLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMaxLonF", 0, 0, (void *)"mpMaxLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMinLatF", 0, 0, (void *)"mpMinLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpMinLonF", 0, 0, (void *)"mpMinLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpProjection", 0, 0, (void *)"mpProjection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRelativeCenterLat", 0, 0, (void *)"mpRelativeCenterLat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRelativeCenterLon", 0, 0, (void *)"mpRelativeCenterLon", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightAngleF", 0, 0, (void *)"mpRightAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightCornerLatF", 0, 0, (void *)"mpRightCornerLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightCornerLonF", 0, 0, (void *)"mpRightCornerLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightMapPosF", 0, 0, (void *)"mpRightMapPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightNDCF", 0, 0, (void *)"mpRightNDCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightNPCF", 0, 0, (void *)"mpRightNPCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightPointLatF", 0, 0, (void *)"mpRightPointLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightPointLonF", 0, 0, (void *)"mpRightPointLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpRightWindowF", 0, 0, (void *)"mpRightWindowF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSatelliteAngle1F", 0, 0, (void *)"mpSatelliteAngle1F", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSatelliteAngle2F", 0, 0, (void *)"mpSatelliteAngle2F", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpSatelliteDistF", 0, 0, (void *)"mpSatelliteDistF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopAngleF", 0, 0, (void *)"mpTopAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopMapPosF", 0, 0, (void *)"mpTopMapPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopNDCF", 0, 0, (void *)"mpTopNDCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopNPCF", 0, 0, (void *)"mpTopNPCF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopPointLatF", 0, 0, (void *)"mpTopPointLatF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopPointLonF", 0, 0, (void *)"mpTopPointLonF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNmpTopWindowF", 0, 0, (void *)"mpTopWindowF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmAnnoManagers", 0, 0, (void *)"pmAnnoManagers", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmAnnoViews", 0, 0, (void *)"pmAnnoViews", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarDisplayMode", 0, 0, (void *)"pmLabelBarDisplayMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarHeightF", 0, 0, (void *)"pmLabelBarHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarKeepAspect", 0, 0, (void *)"pmLabelBarKeepAspect", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarOrthogonalPosF", 0, 0, (void *)"pmLabelBarOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarParallelPosF", 0, 0, (void *)"pmLabelBarParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarSide", 0, 0, (void *)"pmLabelBarSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarWidthF", 0, 0, (void *)"pmLabelBarWidthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLabelBarZone", 0, 0, (void *)"pmLabelBarZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendDisplayMode", 0, 0, (void *)"pmLegendDisplayMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendHeightF", 0, 0, (void *)"pmLegendHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendKeepAspect", 0, 0, (void *)"pmLegendKeepAspect", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendOrthogonalPosF", 0, 0, (void *)"pmLegendOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendParallelPosF", 0, 0, (void *)"pmLegendParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendSide", 0, 0, (void *)"pmLegendSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendWidthF", 0, 0, (void *)"pmLegendWidthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmLegendZone", 0, 0, (void *)"pmLegendZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmOverlaySequenceIds", 0, 0, (void *)"pmOverlaySequenceIds", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmTickMarkDisplayMode", 0, 0, (void *)"pmTickMarkDisplayMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmTickMarkZone", 0, 0, (void *)"pmTickMarkZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmTitleDisplayMode", 0, 0, (void *)"pmTitleDisplayMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNpmTitleZone", 0, 0, (void *)"pmTitleZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNprGraphicStyle", 0, 0, (void *)"prGraphicStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNprPolyType", 0, 0, (void *)"prPolyType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNprXArray", 0, 0, (void *)"prXArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNprYArray", 0, 0, (void *)"prYArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfCopyData", 0, 0, (void *)"sfCopyData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfDataArray", 0, 0, (void *)"sfDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfDataMaxV", 0, 0, (void *)"sfDataMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfDataMinV", 0, 0, (void *)"sfDataMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfExchangeDimensions", 0, 0, (void *)"sfExchangeDimensions", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfMissingValueV", 0, 0, (void *)"sfMissingValueV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXArray", 0, 0, (void *)"sfXArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCActualEndF", 0, 0, (void *)"sfXCActualEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCActualStartF", 0, 0, (void *)"sfXCActualStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCEndIndex", 0, 0, (void *)"sfXCEndIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCEndSubsetV", 0, 0, (void *)"sfXCEndSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCEndV", 0, 0, (void *)"sfXCEndV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCStartIndex", 0, 0, (void *)"sfXCStartIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCStartSubsetV", 0, 0, (void *)"sfXCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCStartV", 0, 0, (void *)"sfXCStartV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfXCStride", 0, 0, (void *)"sfXCStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYArray", 0, 0, (void *)"sfYArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCActualEndF", 0, 0, (void *)"sfYCActualEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCActualStartF", 0, 0, (void *)"sfYCActualStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCEndIndex", 0, 0, (void *)"sfYCEndIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCEndSubsetV", 0, 0, (void *)"sfYCEndSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCEndV", 0, 0, (void *)"sfYCEndV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCStartIndex", 0, 0, (void *)"sfYCStartIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCStartSubsetV", 0, 0, (void *)"sfYCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCStartV", 0, 0, (void *)"sfYCStartV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNsfYCStride", 0, 0, (void *)"sfYCStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstArrowLengthF", 0, 0, (void *)"stArrowLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstArrowStride", 0, 0, (void *)"stArrowStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstCrossoverCheckCount", 0, 0, (void *)"stCrossoverCheckCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstExplicitLabelBarLabelsOn", 0, 0, (void *)"stExplicitLabelBarLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLabelBarEndLabelsOn", 0, 0, (void *)"stLabelBarEndLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLabelFormat", 0, 0, (void *)"stLabelFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLengthCheckCount", 0, 0, (void *)"stLengthCheckCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLevelColors", 0, 0, (void *)"stLevelColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLevelCount", 0, 0, (void *)"stLevelCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLevelSelectionMode", 0, 0, (void *)"stLevelSelectionMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLevelSpacingF", 0, 0, (void *)"stLevelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLevels", 0, 0, (void *)"stLevels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLineColor", 0, 0, (void *)"stLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLineStartStride", 0, 0, (void *)"stLineStartStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstLineThicknessF", 0, 0, (void *)"stLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMapDirection", 0, 0, (void *)"stMapDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMaxLevelCount", 0, 0, (void *)"stMaxLevelCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMaxLevelValF", 0, 0, (void *)"stMaxLevelValF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMinArrowSpacingF", 0, 0, (void *)"stMinArrowSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMinDistanceF", 0, 0, (void *)"stMinDistanceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMinLevelValF", 0, 0, (void *)"stMinLevelValF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMinLineSpacingF", 0, 0, (void *)"stMinLineSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMinStepFactorF", 0, 0, (void *)"stMinStepFactorF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstMonoLineColor", 0, 0, (void *)"stMonoLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstNoDataLabelOn", 0, 0, (void *)"stNoDataLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstNoDataLabelString", 0, 0, (void *)"stNoDataLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstScalarFieldData", 0, 0, (void *)"stScalarFieldData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstScalarMissingValColor", 0, 0, (void *)"stScalarMissingValColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstStepSizeF", 0, 0, (void *)"stStepSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstStreamlineDrawOrder", 0, 0, (void *)"stStreamlineDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstUseScalarArray", 0, 0, (void *)"stUseScalarArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstVectorFieldData", 0, 0, (void *)"stVectorFieldData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfDataArray", 0, 0, (void *)"vfDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfUDataArray", 0, 0, (void *)"vfUDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfVDataArray", 0, 0, (void *)"vfVDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXArray", 0, 0, (void *)"vfXArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYArray", 0, 0, (void *)"vfYArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfGridType", 0, 0, (void *)"vfGridType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfPolarData", 0, 0, (void *)"vfPolarData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfSubsetByIndex", 0, 0, (void *)"vfSubsetByIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfCopyData", 0, 0, (void *)"vfCopyData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfExchangeDimensions", 0, 0, (void *)"vfExchangeDimensions", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfExchangeUVData", 0, 0, (void *)"vfExchangeUVData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfSingleMissingValue", 0, 0, (void *)"vfSingleMissingValue", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfMissingUValueV", 0, 0, (void *)"vfMissingUValueV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfMissingVValueV", 0, 0, (void *)"vfMissingVValueV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfMagMinV", 0, 0, (void *)"vfMagMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfMagMaxV", 0, 0, (void *)"vfMagMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfUMinV", 0, 0, (void *)"vfUMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfUMaxV", 0, 0, (void *)"vfUMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfVMinV", 0, 0, (void *)"vfVMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfVMaxV", 0, 0, (void *)"vfVMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCStartV", 0, 0, (void *)"vfXCStartV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCEndV", 0, 0, (void *)"vfXCEndV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCStartV", 0, 0, (void *)"vfYCStartV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCEndV", 0, 0, (void *)"vfYCEndV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCStartSubsetV", 0, 0, (void *)"vfXCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCEndSubsetV", 0, 0, (void *)"vfXCEndSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCStartSubset", 0, 0, (void *)"vfYCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCEndSubsetV", 0, 0, (void *)"vfYCEndSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCStartIndex", 0, 0, (void *)"vfXCStartIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCEndIndex", 0, 0, (void *)"vfXCEndIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCStartIndex", 0, 0, (void *)"vfYCStartIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCEndIndex", 0, 0, (void *)"vfYCEndIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCStride", 0, 0, (void *)"vfXCStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCStride", 0, 0, (void *)"vfYCStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCActualStartF", 0, 0, (void *)"vfXCActualStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCActualEndF", 0, 0, (void *)"vfXCActualEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfXCElementCount", 0, 0, (void *)"vfXCElementCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCActualStartF", 0, 0, (void *)"vfYCActualStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCActualEndF", 0, 0, (void *)"vfYCActualEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCElementCount", 0, 0, (void *)"vfYCElementCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfDataArray", 0, 0, (void *)"VfDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfUDataArray", 0, 0, (void *)"VfUDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfVDataArray", 0, 0, (void *)"VfVDataArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXArray", 0, 0, (void *)"VfXArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYArray", 0, 0, (void *)"VfYArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfGridType", 0, 0, (void *)"VfGridType", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfPolarData", 0, 0, (void *)"VfPolarData", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfSubsetByIndex", 0, 0, (void *)"VfSubsetByIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfCopyData", 0, 0, (void *)"VfCopyData", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfExchangeDimensions", 0, 0, (void *)"VfExchangeDimensions", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfExchangeUVData", 0, 0, (void *)"VfExchangeUVData", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfSingleMissingValue", 0, 0, (void *)"VfSingleMissingValue", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfMissingUValueV", 0, 0, (void *)"VfMissingUValueV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfMissingVValueV", 0, 0, (void *)"VfMissingVValueV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfMagMinV", 0, 0, (void *)"VfMagMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfMagMaxV", 0, 0, (void *)"VfMagMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfUMinV", 0, 0, (void *)"VfUMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfUMaxV", 0, 0, (void *)"VfUMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfVMinV", 0, 0, (void *)"VfVMinV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfVMaxV", 0, 0, (void *)"VfVMaxV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCStartV", 0, 0, (void *)"VfXCStartV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCEndV", 0, 0, (void *)"VfXCEndV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCStartV", 0, 0, (void *)"VfYCStartV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCEndV", 0, 0, (void *)"VfYCEndV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCStartSubsetV", 0, 0, (void *)"VfXCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCEndSubsetV", 0, 0, (void *)"VfXCEndSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCStartSubsetV", 0, 0, (void *)"VfYCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCEndSubsetV", 0, 0, (void *)"VfYCEndSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCStartIndex", 0, 0, (void *)"VfXCStartIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCEndIndex", 0, 0, (void *)"VfXCEndIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCStartIndex", 0, 0, (void *)"VfYCStartIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCEndIndex", 0, 0, (void *)"VfYCEndIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCStride", 0, 0, (void *)"VfXCStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCStride", 0, 0, (void *)"VfYCStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCActualStartF", 0, 0, (void *)"VfXCActualStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCActualEndF", 0, 0, (void *)"VfXCActualEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfXCElementCount", 0, 0, (void *)"VfXCElementCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCActualStartF", 0, 0, (void *)"VfYCActualStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCActualEndF", 0, 0, (void *)"VfYCActualEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlCvfYCElementCount", 0, 0, (void *)"VfYCElementCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelAngleF", 0, 0, (void *)"stZeroFLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelBackgroundColor", 0, 0, (void *)"stZeroFLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelConstantSpacingF", 0, 0, (void *)"stZeroFLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFont", 0, 0, (void *)"stZeroFLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFontAspectF", 0, 0, (void *)"stZeroFLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFontColor", 0, 0, (void *)"stZeroFLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFontHeightF", 0, 0, (void *)"stZeroFLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFontQuality", 0, 0, (void *)"stZeroFLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFontThicknessF", 0, 0, (void *)"stZeroFLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelFuncCode", 0, 0, (void *)"stZeroFLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelJust", 0, 0, (void *)"stZeroFLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelOn", 0, 0, (void *)"stZeroFLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelOrthogonalPosF", 0, 0, (void *)"stZeroFLabelOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelParallelPosF", 0, 0, (void *)"stZeroFLabelParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelPerimColor", 0, 0, (void *)"stZeroFLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelPerimOn", 0, 0, (void *)"stZeroFLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelPerimSpaceF", 0, 0, (void *)"stZeroFLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelPerimThicknessF", 0, 0, (void *)"stZeroFLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelSide", 0, 0, (void *)"stZeroFLabelSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelString", 0, 0, (void *)"stZeroFLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelTextDirection", 0, 0, (void *)"stZeroFLabelTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNstZeroFLabelZone", 0, 0, (void *)"stZeroFLabelZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtfDoNDCOverlay", 0, 0, (void *)"tfDoNDCOverlay", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtfPlotManagerOn", 0, 0, (void *)"tfPlotManagerOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtfPolyDrawList", 0, 0, (void *)"tfPolyDrawList", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtfPolyDrawOrder", 0, 0, (void *)"tfPolyDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiDeltaF", 0, 0, (void *)"tiDeltaF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainAngleF", 0, 0, (void *)"tiMainAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainConstantSpacingF", 0, 0, (void *)"tiMainConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainDirection", 0, 0, (void *)"tiMainDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFont", 0, 0, (void *)"tiMainFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFontAspectF", 0, 0, (void *)"tiMainFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFontColor", 0, 0, (void *)"tiMainFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFontHeightF", 0, 0, (void *)"tiMainFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFontQuality", 0, 0, (void *)"tiMainFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFontThicknessF", 0, 0, (void *)"tiMainFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainFuncCode", 0, 0, (void *)"tiMainFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainJust", 0, 0, (void *)"tiMainJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainOffsetXF", 0, 0, (void *)"tiMainOffsetXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainOffsetYF", 0, 0, (void *)"tiMainOffsetYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainOn", 0, 0, (void *)"tiMainOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainPosition", 0, 0, (void *)"tiMainPosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainSide", 0, 0, (void *)"tiMainSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiMainString", 0, 0, (void *)"tiMainString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiUseMainAttributes", 0, 0, (void *)"tiUseMainAttributes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisAngleF", 0, 0, (void *)"tiXAxisAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisConstantSpacingF", 0, 0, (void *)"tiXAxisConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisDirection", 0, 0, (void *)"tiXAxisDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFont", 0, 0, (void *)"tiXAxisFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFontAspectF", 0, 0, (void *)"tiXAxisFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFontColor", 0, 0, (void *)"tiXAxisFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFontHeightF", 0, 0, (void *)"tiXAxisFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFontQuality", 0, 0, (void *)"tiXAxisFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFontThicknessF", 0, 0, (void *)"tiXAxisFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisFuncCode", 0, 0, (void *)"tiXAxisFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisJust", 0, 0, (void *)"tiXAxisJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisOffsetXF", 0, 0, (void *)"tiXAxisOffsetXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisOffsetYF", 0, 0, (void *)"tiXAxisOffsetYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisOn", 0, 0, (void *)"tiXAxisOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisPosition", 0, 0, (void *)"tiXAxisPosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisSide", 0, 0, (void *)"tiXAxisSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiXAxisString", 0, 0, (void *)"tiXAxisString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisAngleF", 0, 0, (void *)"tiYAxisAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisConstantSpacingF", 0, 0, (void *)"tiYAxisConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisDirection", 0, 0, (void *)"tiYAxisDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFont", 0, 0, (void *)"tiYAxisFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFontAspectF", 0, 0, (void *)"tiYAxisFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFontColor", 0, 0, (void *)"tiYAxisFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFontHeightF", 0, 0, (void *)"tiYAxisFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFontQuality", 0, 0, (void *)"tiYAxisFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFontThicknessF", 0, 0, (void *)"tiYAxisFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisFuncCode", 0, 0, (void *)"tiYAxisFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisJust", 0, 0, (void *)"tiYAxisJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisOffsetXF", 0, 0, (void *)"tiYAxisOffsetXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisOffsetYF", 0, 0, (void *)"tiYAxisOffsetYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisOn", 0, 0, (void *)"tiYAxisOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisPosition", 0, 0, (void *)"tiYAxisPosition", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisSide", 0, 0, (void *)"tiYAxisSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtiYAxisString", 0, 0, (void *)"tiYAxisString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmBorderLineColor", 0, 0, (void *)"tmBorderLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmBorderThicknessF", 0, 0, (void *)"tmBorderThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmEqualizeXYSizes", 0, 0, (void *)"tmEqualizeXYSizes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmLabelAutoStride", 0, 0, (void *)"tmLabelAutoStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmSciNoteCutoff", 0, 0, (void *)"tmSciNoteCutoff", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBAutoPrecision", 0, 0, (void *)"tmXBAutoPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBBorderOn", 0, 0, (void *)"tmXBBorderOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBDataLeftF", 0, 0, (void *)"tmXBDataLeftF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBDataRightF", 0, 0, (void *)"tmXBDataRightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBFormat", 0, 0, (void *)"tmXBFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBIrrTensionF", 0, 0, (void *)"tmXBIrrTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBIrregularPoints", 0, 0, (void *)"tmXBIrregularPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelAngleF", 0, 0, (void *)"tmXBLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelConstantSpacingF", 0, 0, (void *)"tmXBLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelDeltaF", 0, 0, (void *)"tmXBLabelDeltaF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelDirection", 0, 0, (void *)"tmXBLabelDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFont", 0, 0, (void *)"tmXBLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFontAspectF", 0, 0, (void *)"tmXBLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFontColor", 0, 0, (void *)"tmXBLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFontHeightF", 0, 0, (void *)"tmXBLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFontQuality", 0, 0, (void *)"tmXBLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFontThicknessF", 0, 0, (void *)"tmXBLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelFuncCode", 0, 0, (void *)"tmXBLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelJust", 0, 0, (void *)"tmXBLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelStride", 0, 0, (void *)"tmXBLabelStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabels", 0, 0, (void *)"tmXBLabels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBLabelsOn", 0, 0, (void *)"tmXBLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMajorLengthF", 0, 0, (void *)"tmXBMajorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMajorLineColor", 0, 0, (void *)"tmXBMajorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMajorOutwardLengthF", 0, 0, (void *)"tmXBMajorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMajorThicknessF", 0, 0, (void *)"tmXBMajorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMaxLabelLenF", 0, 0, (void *)"tmXBMaxLabelLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMaxTicks", 0, 0, (void *)"tmXBMaxTicks", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinLabelSpacingF", 0, 0, (void *)"tmXBMinLabelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorLengthF", 0, 0, (void *)"tmXBMinorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorLineColor", 0, 0, (void *)"tmXBMinorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorOn", 0, 0, (void *)"tmXBMinorOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorOutwardLengthF", 0, 0, (void *)"tmXBMinorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorPerMajor", 0, 0, (void *)"tmXBMinorPerMajor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorThicknessF", 0, 0, (void *)"tmXBMinorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMinorValues", 0, 0, (void *)"tmXBMinorValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBMode", 0, 0, (void *)"tmXBMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBOn", 0, 0, (void *)"tmXBOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBPrecision", 0, 0, (void *)"tmXBPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBStyle", 0, 0, (void *)"tmXBStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBTickEndF", 0, 0, (void *)"tmXBTickEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBTickSpacingF", 0, 0, (void *)"tmXBTickSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBTickStartF", 0, 0, (void *)"tmXBTickStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXBValues", 0, 0, (void *)"tmXBValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMajorGrid", 0, 0, (void *)"tmXMajorGrid", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMajorGridLineColor", 0, 0, (void *)"tmXMajorGridLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMajorGridLineDashPattern", 0, 0, (void *)"tmXMajorGridLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMajorGridThicknessF", 0, 0, (void *)"tmXMajorGridThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMinorGrid", 0, 0, (void *)"tmXMinorGrid", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMinorGridLineColor", 0, 0, (void *)"tmXMinorGridLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMinorGridLineDashPattern", 0, 0, (void *)"tmXMinorGridLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXMinorGridThicknessF", 0, 0, (void *)"tmXMinorGridThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTAutoPrecision", 0, 0, (void *)"tmXTAutoPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTBorderOn", 0, 0, (void *)"tmXTBorderOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTDataLeftF", 0, 0, (void *)"tmXTDataLeftF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTDataRightF", 0, 0, (void *)"tmXTDataRightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTFormat", 0, 0, (void *)"tmXTFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTIrrTensionF", 0, 0, (void *)"tmXTIrrTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTIrregularPoints", 0, 0, (void *)"tmXTIrregularPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelAngleF", 0, 0, (void *)"tmXTLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelConstantSpacingF", 0, 0, (void *)"tmXTLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelDeltaF", 0, 0, (void *)"tmXTLabelDeltaF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelDirection", 0, 0, (void *)"tmXTLabelDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFont", 0, 0, (void *)"tmXTLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFontAspectF", 0, 0, (void *)"tmXTLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFontColor", 0, 0, (void *)"tmXTLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFontHeightF", 0, 0, (void *)"tmXTLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFontQuality", 0, 0, (void *)"tmXTLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFontThicknessF", 0, 0, (void *)"tmXTLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelFuncCode", 0, 0, (void *)"tmXTLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelJust", 0, 0, (void *)"tmXTLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelStride", 0, 0, (void *)"tmXTLabelStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabels", 0, 0, (void *)"tmXTLabels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTLabelsOn", 0, 0, (void *)"tmXTLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMajorLengthF", 0, 0, (void *)"tmXTMajorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMajorLineColor", 0, 0, (void *)"tmXTMajorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMajorOutwardLengthF", 0, 0, (void *)"tmXTMajorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMajorThicknessF", 0, 0, (void *)"tmXTMajorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMaxLabelLenF", 0, 0, (void *)"tmXTMaxLabelLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMaxTicks", 0, 0, (void *)"tmXTMaxTicks", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinLabelSpacingF", 0, 0, (void *)"tmXTMinLabelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorLengthF", 0, 0, (void *)"tmXTMinorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorLineColor", 0, 0, (void *)"tmXTMinorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorOn", 0, 0, (void *)"tmXTMinorOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorOutwardLengthF", 0, 0, (void *)"tmXTMinorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorPerMajor", 0, 0, (void *)"tmXTMinorPerMajor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorThicknessF", 0, 0, (void *)"tmXTMinorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMinorValues", 0, 0, (void *)"tmXTMinorValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTMode", 0, 0, (void *)"tmXTMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTOn", 0, 0, (void *)"tmXTOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTPrecision", 0, 0, (void *)"tmXTPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTStyle", 0, 0, (void *)"tmXTStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTTickEndF", 0, 0, (void *)"tmXTTickEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTTickSpacingF", 0, 0, (void *)"tmXTTickSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTTickStartF", 0, 0, (void *)"tmXTTickStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXTValues", 0, 0, (void *)"tmXTValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmXUseBottom", 0, 0, (void *)"tmXUseBottom", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLAutoPrecision", 0, 0, (void *)"tmYLAutoPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLBorderOn", 0, 0, (void *)"tmYLBorderOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLDataBottomF", 0, 0, (void *)"tmYLDataBottomF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLDataTopF", 0, 0, (void *)"tmYLDataTopF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLFormat", 0, 0, (void *)"tmYLFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLIrrTensionF", 0, 0, (void *)"tmYLIrrTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLIrregularPoints", 0, 0, (void *)"tmYLIrregularPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelAngleF", 0, 0, (void *)"tmYLLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelConstantSpacingF", 0, 0, (void *)"tmYLLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelDeltaF", 0, 0, (void *)"tmYLLabelDeltaF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelDirection", 0, 0, (void *)"tmYLLabelDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFont", 0, 0, (void *)"tmYLLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFontAspectF", 0, 0, (void *)"tmYLLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFontColor", 0, 0, (void *)"tmYLLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFontHeightF", 0, 0, (void *)"tmYLLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFontQuality", 0, 0, (void *)"tmYLLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFontThicknessF", 0, 0, (void *)"tmYLLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelFuncCode", 0, 0, (void *)"tmYLLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelJust", 0, 0, (void *)"tmYLLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelStride", 0, 0, (void *)"tmYLLabelStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabels", 0, 0, (void *)"tmYLLabels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLLabelsOn", 0, 0, (void *)"tmYLLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMajorLengthF", 0, 0, (void *)"tmYLMajorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMajorLineColor", 0, 0, (void *)"tmYLMajorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMajorOutwardLengthF", 0, 0, (void *)"tmYLMajorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMajorThicknessF", 0, 0, (void *)"tmYLMajorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMaxLabelLenF", 0, 0, (void *)"tmYLMaxLabelLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMaxTicks", 0, 0, (void *)"tmYLMaxTicks", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinLabelSpacingF", 0, 0, (void *)"tmYLMinLabelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorLengthF", 0, 0, (void *)"tmYLMinorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorLineColor", 0, 0, (void *)"tmYLMinorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorOn", 0, 0, (void *)"tmYLMinorOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorOutwardLengthF", 0, 0, (void *)"tmYLMinorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorPerMajor", 0, 0, (void *)"tmYLMinorPerMajor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorThicknessF", 0, 0, (void *)"tmYLMinorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMinorValues", 0, 0, (void *)"tmYLMinorValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLMode", 0, 0, (void *)"tmYLMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLOn", 0, 0, (void *)"tmYLOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLPrecision", 0, 0, (void *)"tmYLPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLStyle", 0, 0, (void *)"tmYLStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLTickEndF", 0, 0, (void *)"tmYLTickEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLTickSpacingF", 0, 0, (void *)"tmYLTickSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLTickStartF", 0, 0, (void *)"tmYLTickStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYLValues", 0, 0, (void *)"tmYLValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMajorGrid", 0, 0, (void *)"tmYMajorGrid", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMajorGridLineColor", 0, 0, (void *)"tmYMajorGridLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMajorGridLineDashPattern", 0, 0, (void *)"tmYMajorGridLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMajorGridThicknessF", 0, 0, (void *)"tmYMajorGridThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMinorGrid", 0, 0, (void *)"tmYMinorGrid", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMinorGridLineColor", 0, 0, (void *)"tmYMinorGridLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMinorGridLineDashPattern", 0, 0, (void *)"tmYMinorGridLineDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYMinorGridThicknessF", 0, 0, (void *)"tmYMinorGridThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRAutoPrecision", 0, 0, (void *)"tmYRAutoPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRBorderOn", 0, 0, (void *)"tmYRBorderOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRDataBottomF", 0, 0, (void *)"tmYRDataBottomF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRDataTopF", 0, 0, (void *)"tmYRDataTopF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRFormat", 0, 0, (void *)"tmYRFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRIrrTensionF", 0, 0, (void *)"tmYRIrrTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRIrregularPoints", 0, 0, (void *)"tmYRIrregularPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelAngleF", 0, 0, (void *)"tmYRLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelConstantSpacingF", 0, 0, (void *)"tmYRLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelDeltaF", 0, 0, (void *)"tmYRLabelDeltaF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelDirection", 0, 0, (void *)"tmYRLabelDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFont", 0, 0, (void *)"tmYRLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFontAspectF", 0, 0, (void *)"tmYRLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFontColor", 0, 0, (void *)"tmYRLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFontHeightF", 0, 0, (void *)"tmYRLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFontQuality", 0, 0, (void *)"tmYRLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFontThicknessF", 0, 0, (void *)"tmYRLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelFuncCode", 0, 0, (void *)"tmYRLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelJust", 0, 0, (void *)"tmYRLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelStride", 0, 0, (void *)"tmYRLabelStride", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabels", 0, 0, (void *)"tmYRLabels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRLabelsOn", 0, 0, (void *)"tmYRLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMajorLengthF", 0, 0, (void *)"tmYRMajorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMajorLineColor", 0, 0, (void *)"tmYRMajorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMajorOutwardLengthF", 0, 0, (void *)"tmYRMajorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMajorThicknessF", 0, 0, (void *)"tmYRMajorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMaxLabelLenF", 0, 0, (void *)"tmYRMaxLabelLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMaxTicks", 0, 0, (void *)"tmYRMaxTicks", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinLabelSpacingF", 0, 0, (void *)"tmYRMinLabelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorLengthF", 0, 0, (void *)"tmYRMinorLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorLineColor", 0, 0, (void *)"tmYRMinorLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorOn", 0, 0, (void *)"tmYRMinorOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorOutwardLengthF", 0, 0, (void *)"tmYRMinorOutwardLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorPerMajor", 0, 0, (void *)"tmYRMinorPerMajor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorThicknessF", 0, 0, (void *)"tmYRMinorThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMinorValues", 0, 0, (void *)"tmYRMinorValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRMode", 0, 0, (void *)"tmYRMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYROn", 0, 0, (void *)"tmYROn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRPrecision", 0, 0, (void *)"tmYRPrecision", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRStyle", 0, 0, (void *)"tmYRStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRTickEndF", 0, 0, (void *)"tmYRTickEndF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRTickSpacingF", 0, 0, (void *)"tmYRTickSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRTickStartF", 0, 0, (void *)"tmYRTickStartF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYRValues", 0, 0, (void *)"tmYRValues", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtmYUseLeft", 0, 0, (void *)"tmYUseLeft", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXAxisType", 0, 0, (void *)"trXAxisType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXCoordPoints", 0, 0, (void *)"trXCoordPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXInterPoints", 0, 0, (void *)"trXInterPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXSamples", 0, 0, (void *)"trXSamples", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXTensionF", 0, 0, (void *)"trXTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYAxisType", 0, 0, (void *)"trYAxisType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYCoordPoints", 0, 0, (void *)"trYCoordPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYInterPoints", 0, 0, (void *)"trYInterPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYSamples", 0, 0, (void *)"trYSamples", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYTensionF", 0, 0, (void *)"trYTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXLog", 0, 0, (void *)"trXLog", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYLog", 0, 0, (void *)"trYLog", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrLineInterpolationOn", 0, 0, (void *)"trLineInterpolationOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXMaxF", 0, 0, (void *)"trXMaxF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXMinF", 0, 0, (void *)"trXMinF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrXReverse", 0, 0, (void *)"trXReverse", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYMaxF", 0, 0, (void *)"trYMaxF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYMinF", 0, 0, (void *)"trYMinF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtrYReverse", 0, 0, (void *)"trYReverse", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxAngleF", 0, 0, (void *)"txAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxBackgroundFillColor", 0, 0, (void *)"txBackgroundFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxConstantSpacingF", 0, 0, (void *)"txConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxDirection", 0, 0, (void *)"txDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFont", 0, 0, (void *)"txFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFontAspectF", 0, 0, (void *)"txFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFontColor", 0, 0, (void *)"txFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFontHeightF", 0, 0, (void *)"txFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFontQuality", 0, 0, (void *)"txFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFontThicknessF", 0, 0, (void *)"txFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxFuncCode", 0, 0, (void *)"txFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxJust", 0, 0, (void *)"txJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPerimColor", 0, 0, (void *)"txPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPerimDashLengthF", 0, 0, (void *)"txPerimDashLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPerimDashPattern", 0, 0, (void *)"txPerimDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPerimOn", 0, 0, (void *)"txPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPerimSpaceF", 0, 0, (void *)"txPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPerimThicknessF", 0, 0, (void *)"txPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPosXF", 0, 0, (void *)"txPosXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxPosYF", 0, 0, (void *)"txPosYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNtxString", 0, 0, (void *)"txString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcExplicitLabelBarLabelsOn", 0, 0, (void *)"vcExplicitLabelBarLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowEdgeColor", 0, 0, (void *)"vcFillArrowEdgeColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowEdgeThicknessF", 0, 0, (void *)"vcFillArrowEdgeThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowFillColor", 0, 0, (void *)"vcFillArrowFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowHeadInteriorXF", 0, 0, (void *)"vcFillArrowHeadInteriorXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowHeadMinFracXF", 0, 0, (void *)"vcFillArrowHeadMinFracXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowHeadMinFracYF", 0, 0, (void *)"vcFillArrowHeadMinFracYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowHeadXF", 0, 0, (void *)"vcFillArrowHeadXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowHeadYF", 0, 0, (void *)"vcFillArrowHeadYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowMinFracWidthF", 0, 0, (void *)"vcFillArrowMinFracWidthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowWidthF", 0, 0, (void *)"vcFillArrowWidthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillArrowsOn", 0, 0, (void *)"vcFillArrowsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcFillOverEdge", 0, 0, (void *)"vcFillOverEdge", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcGlyphStyle", 0, 0, (void *)"vcGlyphStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLabelBarEndLabelsOn", 0, 0, (void *)"vcLabelBarEndLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLabelFontColor", 0, 0, (void *)"vcLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLabelFontHeightF", 0, 0, (void *)"vcLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLabelsOn", 0, 0, (void *)"vcLabelsOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLabelsUseVectorColor", 0, 0, (void *)"vcLabelsUseVectorColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLevelColors", 0, 0, (void *)"vcLevelColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLevelCount", 0, 0, (void *)"vcLevelCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLevelSelectionMode", 0, 0, (void *)"vcLevelSelectionMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLevelSpacingF", 0, 0, (void *)"vcLevelSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLevels", 0, 0, (void *)"vcLevels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLineArrowHeadMaxSizeF", 0, 0, (void *)"vcLineArrowHeadMaxSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLineArrowHeadMinSizeF", 0, 0, (void *)"vcLineArrowHeadMinSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcLineArrowThicknessF", 0, 0, (void *)"vcLineArrowThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMagnitudeFormat", 0, 0, (void *)"vcMagnitudeFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMagnitudeScaleFactorF", 0, 0, (void *)"vcMagnitudeScaleFactorF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMagnitudeScaleValueF", 0, 0, (void *)"vcMagnitudeScaleValueF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMagnitudeScalingMode", 0, 0, (void *)"vcMagnitudeScalingMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMapDirection", 0, 0, (void *)"vcMapDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMaxLevelCount", 0, 0, (void *)"vcMaxLevelCount", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMaxLevelValF", 0, 0, (void *)"vcMaxLevelValF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMaxMagnitudeF", 0, 0, (void *)"vcMaxMagnitudeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoAngleF", 0, 0, (void *)"vcMinAnnoAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowAngleF", 0, 0, (void *)"vcMinAnnoArrowAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowEdgeColor", 0, 0, (void *)"vcMinAnnoArrowEdgeColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowFillColor", 0, 0, (void *)"vcMinAnnoArrowFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowLineColor", 0, 0, (void *)"vcMinAnnoArrowLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowMinOffsetF", 0, 0, (void *)"vcMinAnnoArrowMinOffsetF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowSpaceF", 0, 0, (void *)"vcMinAnnoArrowSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoArrowUseVecColor", 0, 0, (void *)"vcMinAnnoArrowUseVecColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoBackgroundColor", 0, 0, (void *)"vcMinAnnoBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoConstantSpacingF", 0, 0, (void *)"vcMinAnnoConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoExplicitMagnitudeF", 0, 0, (void *)"vcMinAnnoExplicitMagnitudeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFont", 0, 0, (void *)"vcMinAnnoFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFontAspectF", 0, 0, (void *)"vcMinAnnoFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFontColor", 0, 0, (void *)"vcMinAnnoFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFontHeightF", 0, 0, (void *)"vcMinAnnoFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFontQuality", 0, 0, (void *)"vcMinAnnoFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFontThicknessF", 0, 0, (void *)"vcMinAnnoFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoFuncCode", 0, 0, (void *)"vcMinAnnoFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoJust", 0, 0, (void *)"vcMinAnnoJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoOn", 0, 0, (void *)"vcMinAnnoOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoOrientation", 0, 0, (void *)"vcMinAnnoOrientation", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoOrthogonalPosF", 0, 0, (void *)"vcMinAnnoOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoParallelPosF", 0, 0, (void *)"vcMinAnnoParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoPerimColor", 0, 0, (void *)"vcMinAnnoPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoPerimOn", 0, 0, (void *)"vcMinAnnoPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoPerimSpaceF", 0, 0, (void *)"vcMinAnnoPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoPerimThicknessF", 0, 0, (void *)"vcMinAnnoPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoSide", 0, 0, (void *)"vcMinAnnoSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoString1", 0, 0, (void *)"vcMinAnnoString1", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoString1On", 0, 0, (void *)"vcMinAnnoString1On", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoString2", 0, 0, (void *)"vcMinAnnoString2", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoString2On", 0, 0, (void *)"vcMinAnnoString2On", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoTextDirection", 0, 0, (void *)"vcMinAnnoTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinAnnoZone", 0, 0, (void *)"vcMinAnnoZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinDistanceF", 0, 0, (void *)"vcMinDistanceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinFracLengthF", 0, 0, (void *)"vcMinFracLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinLevelValF", 0, 0, (void *)"vcMinLevelValF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMinMagnitudeF", 0, 0, (void *)"vcMinMagnitudeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMonoFillArrowEdgeColor", 0, 0, (void *)"vcMonoFillArrowEdgeColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMonoFillArrowFillColor", 0, 0, (void *)"vcMonoFillArrowFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMonoLineArrowColor", 0, 0, (void *)"vcMonoLineArrowColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcMonoWindBarbColor", 0, 0, (void *)"vcMonoWindBarbColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcNoDataLabelOn", 0, 0, (void *)"vcNoDataLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcNoDataLabelString", 0, 0, (void *)"vcNoDataLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcPositionMode", 0, 0, (void *)"vcPositionMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoAngleF", 0, 0, (void *)"vcRefAnnoAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowAngleF", 0, 0, (void *)"vcRefAnnoArrowAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowEdgeColor", 0, 0, (void *)"vcRefAnnoArrowEdgeColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowFillColor", 0, 0, (void *)"vcRefAnnoArrowFillColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowLineColor", 0, 0, (void *)"vcRefAnnoArrowLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowMinOffsetF", 0, 0, (void *)"vcRefAnnoArrowMinOffsetF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowSpaceF", 0, 0, (void *)"vcRefAnnoArrowSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoArrowUseVecColor", 0, 0, (void *)"vcRefAnnoArrowUseVecColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoBackgroundColor", 0, 0, (void *)"vcRefAnnoBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoConstantSpacingF", 0, 0, (void *)"vcRefAnnoConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoExplicitMagnitudeF", 0, 0, (void *)"vcRefAnnoExplicitMagnitudeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFont", 0, 0, (void *)"vcRefAnnoFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFontAspectF", 0, 0, (void *)"vcRefAnnoFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFontColor", 0, 0, (void *)"vcRefAnnoFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFontHeightF", 0, 0, (void *)"vcRefAnnoFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFontQuality", 0, 0, (void *)"vcRefAnnoFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFontThicknessF", 0, 0, (void *)"vcRefAnnoFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoFuncCode", 0, 0, (void *)"vcRefAnnoFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoJust", 0, 0, (void *)"vcRefAnnoJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoOn", 0, 0, (void *)"vcRefAnnoOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoOrientation", 0, 0, (void *)"vcRefAnnoOrientation", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoOrthogonalPosF", 0, 0, (void *)"vcRefAnnoOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoParallelPosF", 0, 0, (void *)"vcRefAnnoParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoPerimColor", 0, 0, (void *)"vcRefAnnoPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoPerimOn", 0, 0, (void *)"vcRefAnnoPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoPerimSpaceF", 0, 0, (void *)"vcRefAnnoPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoPerimThicknessF", 0, 0, (void *)"vcRefAnnoPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoSide", 0, 0, (void *)"vcRefAnnoSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoString1", 0, 0, (void *)"vcRefAnnoString1", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoString1On", 0, 0, (void *)"vcRefAnnoString1On", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoString2", 0, 0, (void *)"vcRefAnnoString2", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoString2On", 0, 0, (void *)"vcRefAnnoString2On", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoTextDirection", 0, 0, (void *)"vcRefAnnoTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefAnnoZone", 0, 0, (void *)"vcRefAnnoZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefLengthF", 0, 0, (void *)"vcRefLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcRefMagnitudeF", 0, 0, (void *)"vcRefMagnitudeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcScalarFieldData", 0, 0, (void *)"vcScalarFieldData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcScalarMissingValColor", 0, 0, (void *)"vcScalarMissingValColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcScalarValueFormat", 0, 0, (void *)"vcScalarValueFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcScalarValueScaleFactorF", 0, 0, (void *)"vcScalarValueScaleFactorF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcScalarValueScaleValueF", 0, 0, (void *)"vcScalarValueScaleValueF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcScalarValueScalingMode", 0, 0, (void *)"vcScalarValueScalingMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcUseRefAnnoRes", 0, 0, (void *)"vcUseRefAnnoRes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcUseScalarArray", 0, 0, (void *)"vcUseScalarArray", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcVectorDrawOrder", 0, 0, (void *)"vcVectorDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcVectorFieldData", 0, 0, (void *)"vcVectorFieldData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbCalmCircleSizeF", 0, 0, (void *)"vcWindBarbCalmCircleSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbColor", 0, 0, (void *)"vcWindBarbColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbLineThicknessF", 0, 0, (void *)"vcWindBarbLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbScaleFactorF", 0, 0, (void *)"vcWindBarbScaleFactorF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbTickAngleF", 0, 0, (void *)"vcWindBarbTickAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbTickLengthF", 0, 0, (void *)"vcWindBarbTickLengthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcWindBarbTickSpacingF", 0, 0, (void *)"vcWindBarbTickSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelAngleF", 0, 0, (void *)"vcZeroFLabelAngleF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelBackgroundColor", 0, 0, (void *)"vcZeroFLabelBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelConstantSpacingF", 0, 0, (void *)"vcZeroFLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFont", 0, 0, (void *)"vcZeroFLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFontAspectF", 0, 0, (void *)"vcZeroFLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFontColor", 0, 0, (void *)"vcZeroFLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFontHeightF", 0, 0, (void *)"vcZeroFLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFontQuality", 0, 0, (void *)"vcZeroFLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFontThicknessF", 0, 0, (void *)"vcZeroFLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelFuncCode", 0, 0, (void *)"vcZeroFLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelJust", 0, 0, (void *)"vcZeroFLabelJust", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelOn", 0, 0, (void *)"vcZeroFLabelOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelOrthogonalPosF", 0, 0, (void *)"vcZeroFLabelOrthogonalPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelParallelPosF", 0, 0, (void *)"vcZeroFLabelParallelPosF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelPerimColor", 0, 0, (void *)"vcZeroFLabelPerimColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelPerimOn", 0, 0, (void *)"vcZeroFLabelPerimOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelPerimSpaceF", 0, 0, (void *)"vcZeroFLabelPerimSpaceF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelPerimThicknessF", 0, 0, (void *)"vcZeroFLabelPerimThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelSide", 0, 0, (void *)"vcZeroFLabelSide", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelString", 0, 0, (void *)"vcZeroFLabelString", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelTextDirection", 0, 0, (void *)"vcZeroFLabelTextDirection", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvcZeroFLabelZone", 0, 0, (void *)"vcZeroFLabelZone", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvfYCStartSubsetV", 0, 0, (void *)"vfYCStartSubsetV", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpAnnoManagerId", 0, 0, (void *)"vpAnnoManagerId", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpHeightF", 0, 0, (void *)"vpHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpKeepAspect", 0, 0, (void *)"vpKeepAspect", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpOn", 0, 0, (void *)"vpOn", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpUseSegments", 0, 0, (void *)"vpUseSegments", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpWidthF", 0, 0, (void *)"vpWidthF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpXF", 0, 0, (void *)"vpXF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNvpYF", 0, 0, (void *)"vpYF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkMetaName", 0, 0, (void *)"wkMetaName", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkDeviceLowerX", 0, 0, (void *)"wkDeviceLowerX", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkDeviceLowerY", 0, 0, (void *)"wkDeviceLowerY", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkDeviceUpperX", 0, 0, (void *)"wkDeviceUpperX", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkDeviceUpperY", 0, 0, (void *)"wkDeviceUpperY", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPSFileName", 0, 0, (void *)"wkPSFileName", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPSFormat", 0, 0, (void *)"wkPSFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPSResolution", 0, 0, (void *)"wkPSResolution", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPDFFileName", 0, 0, (void *)"wkPDFFileName", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPDFFormat", 0, 0, (void *)"wkPDFFormat", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPDFResolution", 0, 0, (void *)"wkPDFResolution", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkVisualType", 0, 0, (void *)"wkVisualType", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkColorModel", 0, 0, (void *)"wkColorModel", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkBackgroundColor", 0, 0, (void *)"wkBackgroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkColorMap", 0, 0, (void *)"wkColorMap", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkColorMapLen", 0, 0, (void *)"wkColorMapLen", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkDashTableLength", 0, 0, (void *)"wkDashTableLength", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkDefGraphicStyleId", 0, 0, (void *)"wkDefGraphicStyleId", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkFillTableLength", 0, 0, (void *)"wkFillTableLength", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkForegroundColor", 0, 0, (void *)"wkForegroundColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkGksWorkId", 0, 0, (void *)"wkGksWorkId", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkMarkerTableLength", 0, 0, (void *)"wkMarkerTableLength", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkTopLevelViews", 0, 0, (void *)"wkTopLevelViews", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkViews", 0, 0, (void *)"wkViews", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkPause", 0, 0, (void *)"wkPause", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkWindowId", 0, 0, (void *)"wkWindowId", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwkXColorMode", 0, 0, (void *)"wkXColorMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwsCurrentSize", 0, 0, (void *)"wsCurrentSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwsMaximumSize", 0, 0, (void *)"wsMaximumSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNwsThresholdSize", 0, 0, (void *)"wsThresholdSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyComputeXMax", 0, 0, (void *)"xyComputeXMax", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyComputeXMin", 0, 0, (void *)"xyComputeXMin", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyComputeYMax", 0, 0, (void *)"xyComputeYMax", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyComputeYMin", 0, 0, (void *)"xyComputeYMin", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyCoordData", 0, 0, (void *)"xyCoordData", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyCoordDataSpec", 0, 0, (void *)"xyCoordDataSpec", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyCurveDrawOrder", 0, 0, (void *)"xyCurveDrawOrder", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyDashPattern", 0, 0, (void *)"xyDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyDashPatterns", 0, 0, (void *)"xyDashPatterns", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyExplicitLabels", 0, 0, (void *)"xyExplicitLabels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyExplicitLegendLabels", 0, 0, (void *)"xyExplicitLegendLabels", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLabelMode", 0, 0, (void *)"xyLabelMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineColor", 0, 0, (void *)"xyLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineColors", 0, 0, (void *)"xyLineColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineDashSegLenF", 0, 0, (void *)"xyLineDashSegLenF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelConstantSpacingF", 0, 0, (void *)"xyLineLabelConstantSpacingF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFont", 0, 0, (void *)"xyLineLabelFont", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFontAspectF", 0, 0, (void *)"xyLineLabelFontAspectF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFontColor", 0, 0, (void *)"xyLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFontColors", 0, 0, (void *)"xyLineLabelFontColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFontHeightF", 0, 0, (void *)"xyLineLabelFontHeightF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFontQuality", 0, 0, (void *)"xyLineLabelFontQuality", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFontThicknessF", 0, 0, (void *)"xyLineLabelFontThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineLabelFuncCode", 0, 0, (void *)"xyLineLabelFuncCode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineThicknessF", 0, 0, (void *)"xyLineThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyLineThicknesses", 0, 0, (void *)"xyLineThicknesses", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkLineMode", 0, 0, (void *)"xyMarkLineMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkLineModes", 0, 0, (void *)"xyMarkLineModes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarker", 0, 0, (void *)"xyMarker", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkerColor", 0, 0, (void *)"xyMarkerColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkerColors", 0, 0, (void *)"xyMarkerColors", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkerSizeF", 0, 0, (void *)"xyMarkerSizeF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkerSizes", 0, 0, (void *)"xyMarkerSizes", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkerThicknessF", 0, 0, (void *)"xyMarkerThicknessF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkerThicknesses", 0, 0, (void *)"xyMarkerThicknesses", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMarkers", 0, 0, (void *)"xyMarkers", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoDashPattern", 0, 0, (void *)"xyMonoDashPattern", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoLineColor", 0, 0, (void *)"xyMonoLineColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoLineLabelFontColor", 0, 0, (void *)"xyMonoLineLabelFontColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoLineThickness", 0, 0, (void *)"xyMonoLineThickness", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoMarkLineMode", 0, 0, (void *)"xyMonoMarkLineMode", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoMarker", 0, 0, (void *)"xyMonoMarker", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoMarkerColor", 0, 0, (void *)"xyMonoMarkerColor", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoMarkerSize", 0, 0, (void *)"xyMonoMarkerSize", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyMonoMarkerThickness", 0, 0, (void *)"xyMonoMarkerThickness", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyXIrrTensionF", 0, 0, (void *)"xyXIrrTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyXIrregularPoints", 0, 0, (void *)"xyXIrregularPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyXStyle", 0, 0, (void *)"xyXStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyYIrrTensionF", 0, 0, (void *)"xyYIrrTensionF", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyYIrregularPoints", 0, 0, (void *)"xyYIrregularPoints", 0},
{ SWIG_PY_STRING,  (char*)"NhlNxyYStyle", 0, 0, (void *)"xyYStyle", 0},
{ SWIG_PY_STRING,  (char*)"NhlTFillIndexFullEnum", 0, 0, (void *)"FillIndexFullEnum", 0},
{ SWIG_PY_STRING,  (char*)"NhlTFillIndexFullEnumGenArray", 0, 0, (void *)"FillIndexFullEnumGenArray", 0},
{ SWIG_PY_INT,     (char *)"NhlUNSPECIFIEDFILL", (long) -2, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"NhlTFillIndex", 0, 0, (void *)"FillIndex", 0},
{ SWIG_PY_STRING,  (char*)"NhlTFillIndexGenArray", 0, 0, (void *)"FillIndexGenArray", 0},
{ SWIG_PY_INT,     (char *)"NhlHOLLOWFILL", (long) -1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlNULLFILL", (long) -1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlSOLIDFILL", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlWK_INITIAL_FILL_BUFSIZE", (long) 128, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlSETRL", (long) NhlSETRL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlGETRL", (long) NhlGETRL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlFATAL", (long) NhlFATAL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlWARNING", (long) NhlWARNING, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlINFO", (long) NhlINFO, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlNOERROR", (long) NhlNOERROR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlNOLINE", (long) NhlNOLINE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlLINEONLY", (long) NhlLINEONLY, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlLABELONLY", (long) NhlLABELONLY, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlLINEANDLABEL", (long) NhlLINEANDLABEL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlPOLYLINE", (long) NhlPOLYLINE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlPOLYMARKER", (long) NhlPOLYMARKER, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlPOLYGON", (long) NhlPOLYGON, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlDEFAULT_APP", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"False", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"True", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlAUTOMATIC", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlMANUAL", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlEXPLICIT", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlLOG", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlLINEAR", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlIRREGULAR", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlGEOGRAPHIC", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlTIME", (long) 4, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlEUNKNOWN", (long) 1000, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlENODATA", (long) 1101, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlECONSTFIELD", (long) 1102, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlEZEROFIELD", (long) 1103, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NhlEZEROSPAN", (long) 1104, 0, 0, 0},
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    import_array();
    
}

